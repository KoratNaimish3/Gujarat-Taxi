"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_ckeditor_ckeditor5-react_dist_index_js"],{

/***/ "(app-pages-browser)/./node_modules/@ckeditor/ckeditor5-integrations-common/dist/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ckeditor/ckeditor5-integrations-common/dist/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CKBOX_CDN_URL: function() { return /* binding */ CKBOX_CDN_URL; },\n/* harmony export */   CK_CDN_URL: function() { return /* binding */ CK_CDN_URL; },\n/* harmony export */   INJECTED_SCRIPTS: function() { return /* binding */ INJECTED_SCRIPTS; },\n/* harmony export */   INJECTED_STYLESHEETS: function() { return /* binding */ INJECTED_STYLESHEETS; },\n/* harmony export */   appendExtraPluginsToEditorConfig: function() { return /* binding */ appendExtraPluginsToEditorConfig; },\n/* harmony export */   createCKBoxCdnUrl: function() { return /* binding */ createCKBoxCdnUrl; },\n/* harmony export */   createCKCdnUrl: function() { return /* binding */ createCKCdnUrl; },\n/* harmony export */   createDefer: function() { return /* binding */ createDefer; },\n/* harmony export */   createIntegrationUsageDataPlugin: function() { return /* binding */ createIntegrationUsageDataPlugin; },\n/* harmony export */   filterBlankObjectValues: function() { return /* binding */ filterBlankObjectValues; },\n/* harmony export */   filterObjectValues: function() { return /* binding */ filterObjectValues; },\n/* harmony export */   injectScript: function() { return /* binding */ injectScript; },\n/* harmony export */   injectScriptsInParallel: function() { return /* binding */ injectScriptsInParallel; },\n/* harmony export */   injectStylesheet: function() { return /* binding */ injectStylesheet; },\n/* harmony export */   isCKEditorFreeLicense: function() { return /* binding */ isCKEditorFreeLicense; },\n/* harmony export */   isSSR: function() { return /* binding */ isSSR; },\n/* harmony export */   loadCKEditorCloud: function() { return /* binding */ loadCKEditorCloud; },\n/* harmony export */   mapObjectValues: function() { return /* binding */ mapObjectValues; },\n/* harmony export */   once: function() { return /* binding */ once; },\n/* harmony export */   overwriteArray: function() { return /* binding */ overwriteArray; },\n/* harmony export */   overwriteObject: function() { return /* binding */ overwriteObject; },\n/* harmony export */   preloadResource: function() { return /* binding */ preloadResource; },\n/* harmony export */   shallowCompareArrays: function() { return /* binding */ shallowCompareArrays; },\n/* harmony export */   uid: function() { return /* binding */ uid; },\n/* harmony export */   uniq: function() { return /* binding */ uniq; },\n/* harmony export */   waitFor: function() { return /* binding */ waitFor; },\n/* harmony export */   waitForWindowEntry: function() { return /* binding */ waitForWindowEntry; },\n/* harmony export */   without: function() { return /* binding */ without; }\n/* harmony export */ });\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction createDefer() {\n  const deferred = {\n    resolve: null,\n    promise: null\n  };\n  deferred.promise = new Promise((resolve) => {\n    deferred.resolve = resolve;\n  });\n  return deferred;\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction waitFor(callback, {\n  timeOutAfter = 500,\n  retryAfter = 100\n} = {}) {\n  return new Promise((resolve, reject) => {\n    const startTime = Date.now();\n    let lastError = null;\n    const timeoutTimerId = setTimeout(() => {\n      reject(lastError ?? new Error(\"Timeout\"));\n    }, timeOutAfter);\n    const tick = async () => {\n      try {\n        const result = await callback();\n        clearTimeout(timeoutTimerId);\n        resolve(result);\n      } catch (err) {\n        lastError = err;\n        if (Date.now() - startTime > timeOutAfter) {\n          reject(err);\n        } else {\n          setTimeout(tick, retryAfter);\n        }\n      }\n    };\n    tick();\n  });\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst INJECTED_SCRIPTS = /* @__PURE__ */ new Map();\nfunction injectScript(src, { attributes } = {}) {\n  if (INJECTED_SCRIPTS.has(src)) {\n    return INJECTED_SCRIPTS.get(src);\n  }\n  const maybePrevScript = document.querySelector(`script[src=\"${src}\"]`);\n  if (maybePrevScript) {\n    console.warn(`Script with \"${src}\" src is already present in DOM!`);\n    maybePrevScript.remove();\n  }\n  const promise = new Promise((resolve, reject) => {\n    const script = document.createElement(\"script\");\n    script.onerror = reject;\n    script.onload = () => {\n      resolve();\n    };\n    for (const [key, value] of Object.entries(attributes || {})) {\n      script.setAttribute(key, value);\n    }\n    script.setAttribute(\"data-injected-by\", \"ckeditor-integration\");\n    script.type = \"text/javascript\";\n    script.async = true;\n    script.src = src;\n    document.head.appendChild(script);\n    const observer = new MutationObserver((mutations) => {\n      const removedNodes = mutations.flatMap((mutation) => Array.from(mutation.removedNodes));\n      if (removedNodes.includes(script)) {\n        INJECTED_SCRIPTS.delete(src);\n        observer.disconnect();\n      }\n    });\n    observer.observe(document.head, {\n      childList: true,\n      subtree: true\n    });\n  });\n  INJECTED_SCRIPTS.set(src, promise);\n  return promise;\n}\nasync function injectScriptsInParallel(sources, props) {\n  await Promise.all(\n    sources.map((src) => injectScript(src, props))\n  );\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst INJECTED_STYLESHEETS = /* @__PURE__ */ new Map();\nfunction injectStylesheet({\n  href,\n  placementInHead = \"start\",\n  attributes = {}\n}) {\n  if (INJECTED_STYLESHEETS.has(href)) {\n    return INJECTED_STYLESHEETS.get(href);\n  }\n  const maybePrevStylesheet = document.querySelector(`link[href=\"${href}\"][rel=\"stylesheet\"]`);\n  if (maybePrevStylesheet) {\n    console.warn(`Stylesheet with \"${href}\" href is already present in DOM!`);\n    maybePrevStylesheet.remove();\n  }\n  const appendLinkTagToHead = (link) => {\n    const previouslyInjectedLinks = Array.from(\n      document.head.querySelectorAll('link[data-injected-by=\"ckeditor-integration\"]')\n    );\n    switch (placementInHead) {\n      case \"start\":\n        if (previouslyInjectedLinks.length) {\n          previouslyInjectedLinks.slice(-1)[0].after(link);\n        } else {\n          document.head.insertBefore(link, document.head.firstChild);\n        }\n        break;\n      case \"end\":\n        document.head.appendChild(link);\n        break;\n    }\n  };\n  const promise = new Promise((resolve, reject) => {\n    const link = document.createElement(\"link\");\n    for (const [key, value] of Object.entries(attributes || {})) {\n      link.setAttribute(key, value);\n    }\n    link.setAttribute(\"data-injected-by\", \"ckeditor-integration\");\n    link.rel = \"stylesheet\";\n    link.href = href;\n    link.onerror = reject;\n    link.onload = () => {\n      resolve();\n    };\n    appendLinkTagToHead(link);\n    const observer = new MutationObserver((mutations) => {\n      const removedNodes = mutations.flatMap((mutation) => Array.from(mutation.removedNodes));\n      if (removedNodes.includes(link)) {\n        INJECTED_STYLESHEETS.delete(href);\n        observer.disconnect();\n      }\n    });\n    observer.observe(document.head, {\n      childList: true,\n      subtree: true\n    });\n  });\n  INJECTED_STYLESHEETS.set(href, promise);\n  return promise;\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction isSSR() {\n  return typeof window === \"undefined\";\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction once(fn) {\n  let lastResult = null;\n  return (...args) => {\n    if (!lastResult) {\n      lastResult = {\n        current: fn(...args)\n      };\n    }\n    return lastResult.current;\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction overwriteArray(source, destination) {\n  destination.length = 0;\n  destination.push(...source);\n  return destination;\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction overwriteObject(source, destination) {\n  for (const prop of Object.getOwnPropertyNames(destination)) {\n    delete destination[prop];\n  }\n  for (const [key, value] of Object.entries(source)) {\n    if (value !== destination && key !== \"prototype\" && key !== \"__proto__\") {\n      destination[key] = value;\n    }\n  }\n  return destination;\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction preloadResource(url, { attributes } = {}) {\n  if (document.head.querySelector(`link[href=\"${url}\"][rel=\"preload\"]`)) {\n    return;\n  }\n  const link = document.createElement(\"link\");\n  for (const [key, value] of Object.entries(attributes || {})) {\n    link.setAttribute(key, value);\n  }\n  link.setAttribute(\"data-injected-by\", \"ckeditor-integration\");\n  link.rel = \"preload\";\n  link.as = detectTypeOfResource(url);\n  link.href = url;\n  document.head.insertBefore(link, document.head.firstChild);\n}\nfunction detectTypeOfResource(url) {\n  switch (true) {\n    case /\\.css$/.test(url):\n      return \"style\";\n    case /\\.js$/.test(url):\n      return \"script\";\n    default:\n      return \"fetch\";\n  }\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction shallowCompareArrays(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (!a || !b) {\n    return false;\n  }\n  for (let i = 0; i < a.length; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst HEX_NUMBERS = new Array(256).fill(\"\").map((_, index) => (\"0\" + index.toString(16)).slice(-2));\nfunction uid() {\n  const [r1, r2, r3, r4] = crypto.getRandomValues(new Uint32Array(4));\n  return \"e\" + HEX_NUMBERS[r1 >> 0 & 255] + HEX_NUMBERS[r1 >> 8 & 255] + HEX_NUMBERS[r1 >> 16 & 255] + HEX_NUMBERS[r1 >> 24 & 255] + HEX_NUMBERS[r2 >> 0 & 255] + HEX_NUMBERS[r2 >> 8 & 255] + HEX_NUMBERS[r2 >> 16 & 255] + HEX_NUMBERS[r2 >> 24 & 255] + HEX_NUMBERS[r3 >> 0 & 255] + HEX_NUMBERS[r3 >> 8 & 255] + HEX_NUMBERS[r3 >> 16 & 255] + HEX_NUMBERS[r3 >> 24 & 255] + HEX_NUMBERS[r4 >> 0 & 255] + HEX_NUMBERS[r4 >> 8 & 255] + HEX_NUMBERS[r4 >> 16 & 255] + HEX_NUMBERS[r4 >> 24 & 255];\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction uniq(source) {\n  return Array.from(new Set(source));\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nasync function waitForWindowEntry(entryNames, config) {\n  const tryPickBundle = () => entryNames.map((name) => window[name]).filter(Boolean)[0];\n  return waitFor(\n    () => {\n      const result = tryPickBundle();\n      if (!result) {\n        throw new Error(`Window entry \"${entryNames.join(\",\")}\" not found.`);\n      }\n      return result;\n    },\n    config\n  );\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction filterObjectValues(obj, filter) {\n  const filteredEntries = Object.entries(obj).filter(([key, value]) => filter(value, key));\n  return Object.fromEntries(filteredEntries);\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction filterBlankObjectValues(obj) {\n  return filterObjectValues(\n    obj,\n    (value) => value !== null && value !== void 0\n  );\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction mapObjectValues(obj, mapper) {\n  const mappedEntries = Object.entries(obj).map(([key, value]) => [key, mapper(value, key)]);\n  return Object.fromEntries(mappedEntries);\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction without(itemsToRemove, items) {\n  return items.filter((item) => !itemsToRemove.includes(item));\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction appendExtraPluginsToEditorConfig(config, plugins) {\n  const extraPlugins = config.extraPlugins || [];\n  return {\n    ...config,\n    extraPlugins: [\n      ...extraPlugins,\n      ...plugins.filter((item) => !extraPlugins.includes(item))\n    ]\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction isSemanticVersion(version) {\n  return !!version && /^\\d+\\.\\d+\\.\\d+/.test(version);\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction isCKCdnTestingVersion(version) {\n  if (!version) {\n    return false;\n  }\n  return [\"nightly\", \"alpha\", \"internal\", \"nightly-\", \"staging\"].some((testVersion) => version.includes(testVersion));\n}\nfunction isCKCdnVersion(version) {\n  return isSemanticVersion(version) || isCKCdnTestingVersion(version);\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction destructureSemanticVersion(version) {\n  if (!isSemanticVersion(version)) {\n    throw new Error(`Invalid semantic version: ${version || \"<blank>\"}.`);\n  }\n  const [major, minor, patch] = version.split(\".\");\n  return {\n    major: Number.parseInt(major, 10),\n    minor: Number.parseInt(minor, 10),\n    patch: Number.parseInt(patch, 10)\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction getLicenseVersionFromEditorVersion(version) {\n  if (isCKCdnTestingVersion(version)) {\n    return 3;\n  }\n  const { major } = destructureSemanticVersion(version);\n  switch (true) {\n    case major >= 44:\n      return 3;\n    case major >= 38:\n      return 2;\n    default:\n      return 1;\n  }\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction getCKBaseBundleInstallationInfo() {\n  const { CKEDITOR_VERSION, CKEDITOR } = window;\n  if (!isCKCdnVersion(CKEDITOR_VERSION)) {\n    return null;\n  }\n  return {\n    source: CKEDITOR ? \"cdn\" : \"npm\",\n    version: CKEDITOR_VERSION\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction getSupportedLicenseVersionInstallationInfo() {\n  const installationInfo = getCKBaseBundleInstallationInfo();\n  if (!installationInfo) {\n    return null;\n  }\n  return getLicenseVersionFromEditorVersion(installationInfo.version);\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction isCKEditorFreeLicense(licenseKey, licenseVersion) {\n  licenseVersion ||= getSupportedLicenseVersionInstallationInfo() || void 0;\n  switch (licenseVersion) {\n    case 1:\n    case 2:\n      return licenseKey === void 0;\n    case 3:\n      return licenseKey === \"GPL\";\n    default: {\n      return false;\n    }\n  }\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction createIntegrationUsageDataPlugin(integrationName, usageData) {\n  return function IntegrationUsageDataPlugin(editor) {\n    if (isCKEditorFreeLicense(editor.config.get(\"licenseKey\"))) {\n      return;\n    }\n    editor.on(\"collectUsageData\", (source, { setUsageData }) => {\n      setUsageData(`integration.${integrationName}`, usageData);\n    });\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst CK_CDN_URL = \"https://cdn.ckeditor.com\";\nfunction createCKCdnUrl(bundle, file, version) {\n  return `${CK_CDN_URL}/${bundle}/${version}/${file}`;\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst CKBOX_CDN_URL = \"https://cdn.ckbox.io\";\nfunction createCKBoxCdnUrl(bundle, file, version) {\n  return `${CKBOX_CDN_URL}/${bundle}/${version}/${file}`;\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst CK_DOCS_URL = \"https://ckeditor.com/docs/ckeditor5\";\nfunction createCKDocsUrl(path, version = \"latest\") {\n  return `${CK_DOCS_URL}/${version}/${path}`;\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction createCKCdnBaseBundlePack({\n  version,\n  translations,\n  createCustomCdnUrl = createCKCdnUrl\n}) {\n  const urls = {\n    scripts: [\n      // Load the main script of the base features.\n      createCustomCdnUrl(\"ckeditor5\", \"ckeditor5.umd.js\", version),\n      // Load all JavaScript files from the base features.\n      // EN bundle is prebuilt into the main script, so we don't need to load it separately.\n      ...without([\"en\"], translations || []).map(\n        (translation) => createCustomCdnUrl(\"ckeditor5\", `translations/${translation}.umd.js`, version)\n      )\n    ],\n    stylesheets: [\n      createCustomCdnUrl(\"ckeditor5\", \"ckeditor5.css\", version)\n    ]\n  };\n  return {\n    // Preload resources specified in the pack, before loading the main script.\n    preload: [\n      ...urls.stylesheets,\n      ...urls.scripts\n    ],\n    scripts: [\n      // It's safe to load translations and the main script in parallel.\n      async (attributes) => injectScriptsInParallel(urls.scripts, attributes)\n    ],\n    // Load all stylesheets of the base features.\n    stylesheets: urls.stylesheets,\n    // Pick the exported global variables from the window object.\n    checkPluginLoaded: async () => waitForWindowEntry([\"CKEDITOR\"]),\n    // Check if the CKEditor base bundle is already loaded and throw an error if it is.\n    beforeInject: () => {\n      const installationInfo = getCKBaseBundleInstallationInfo();\n      switch (installationInfo?.source) {\n        case \"npm\":\n          throw new Error(\n            \"CKEditor 5 is already loaded from npm. Check the migration guide for more details: \" + createCKDocsUrl(\"updating/migration-to-cdn/vanilla-js.html\")\n          );\n        case \"cdn\":\n          if (installationInfo.version !== version) {\n            throw new Error(\n              `CKEditor 5 is already loaded from CDN in version ${installationInfo.version}. Remove the old <script> and <link> tags loading CKEditor 5 to allow loading the ${version} version.`\n            );\n          }\n          break;\n      }\n    }\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction createCKCdnPremiumBundlePack({\n  version,\n  translations,\n  createCustomCdnUrl = createCKCdnUrl\n}) {\n  const urls = {\n    scripts: [\n      // Load the main script of the premium features.\n      createCustomCdnUrl(\"ckeditor5-premium-features\", \"ckeditor5-premium-features.umd.js\", version),\n      // Load all JavaScript files from the premium features.\n      // EN bundle is prebuilt into the main script, so we don't need to load it separately.\n      ...without([\"en\"], translations || []).map(\n        (translation) => createCustomCdnUrl(\"ckeditor5-premium-features\", `translations/${translation}.umd.js`, version)\n      )\n    ],\n    stylesheets: [\n      createCustomCdnUrl(\"ckeditor5-premium-features\", \"ckeditor5-premium-features.css\", version)\n    ]\n  };\n  return {\n    // Preload resources specified in the pack, before loading the main script.\n    preload: [\n      ...urls.stylesheets,\n      ...urls.scripts\n    ],\n    scripts: [\n      // It's safe to load translations and the main script in parallel.\n      async (attributes) => injectScriptsInParallel(urls.scripts, attributes)\n    ],\n    // Load all stylesheets of the premium features.\n    stylesheets: urls.stylesheets,\n    // Pick the exported global variables from the window object.\n    checkPluginLoaded: async () => waitForWindowEntry([\"CKEDITOR_PREMIUM_FEATURES\"])\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nasync function loadCKCdnResourcesPack(pack) {\n  let {\n    htmlAttributes = {},\n    scripts = [],\n    stylesheets = [],\n    preload,\n    beforeInject,\n    checkPluginLoaded\n  } = normalizeCKCdnResourcesPack(pack);\n  beforeInject?.();\n  if (!preload) {\n    preload = uniq([\n      ...stylesheets.filter((item) => typeof item === \"string\"),\n      ...scripts.filter((item) => typeof item === \"string\")\n    ]);\n  }\n  for (const url of preload) {\n    preloadResource(url, {\n      attributes: htmlAttributes\n    });\n  }\n  await Promise.all(\n    uniq(stylesheets).map((href) => injectStylesheet({\n      href,\n      attributes: htmlAttributes,\n      placementInHead: \"start\"\n    }))\n  );\n  for (const script of uniq(scripts)) {\n    const injectorProps = {\n      attributes: htmlAttributes\n    };\n    if (typeof script === \"string\") {\n      await injectScript(script, injectorProps);\n    } else {\n      await script(injectorProps);\n    }\n  }\n  return checkPluginLoaded?.();\n}\nfunction normalizeCKCdnResourcesPack(pack) {\n  if (Array.isArray(pack)) {\n    return {\n      scripts: pack.filter(\n        (item) => typeof item === \"function\" || item.endsWith(\".js\")\n      ),\n      stylesheets: pack.filter(\n        (item) => item.endsWith(\".css\")\n      )\n    };\n  }\n  if (typeof pack === \"function\") {\n    return {\n      checkPluginLoaded: pack\n    };\n  }\n  return pack;\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction combineCKCdnBundlesPacks(packs) {\n  const normalizedPacks = mapObjectValues(\n    filterBlankObjectValues(packs),\n    normalizeCKCdnResourcesPack\n  );\n  const mergedPacks = Object.values(normalizedPacks).reduce(\n    (acc, pack) => {\n      acc.scripts.push(...pack.scripts ?? []);\n      acc.stylesheets.push(...pack.stylesheets ?? []);\n      acc.preload.push(...pack.preload ?? []);\n      return acc;\n    },\n    {\n      preload: [],\n      scripts: [],\n      stylesheets: []\n    }\n  );\n  const checkPluginLoaded = async () => {\n    const exportedGlobalVariables = /* @__PURE__ */ Object.create(null);\n    for (const [name, pack] of Object.entries(normalizedPacks)) {\n      exportedGlobalVariables[name] = await pack?.checkPluginLoaded?.();\n    }\n    return exportedGlobalVariables;\n  };\n  const beforeInject = () => {\n    for (const pack of Object.values(normalizedPacks)) {\n      pack.beforeInject?.();\n    }\n  };\n  return {\n    ...mergedPacks,\n    beforeInject,\n    checkPluginLoaded\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction getCKBoxInstallationInfo() {\n  const version = window.CKBox?.version;\n  if (!isSemanticVersion(version)) {\n    return null;\n  }\n  return {\n    source: \"cdn\",\n    version\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction createCKBoxBundlePack({\n  version,\n  theme = \"lark\",\n  translations,\n  createCustomCdnUrl = createCKBoxCdnUrl\n}) {\n  return {\n    // Load the main script of the base features.\n    scripts: [\n      createCustomCdnUrl(\"ckbox\", \"ckbox.js\", version),\n      // EN bundle is prebuilt into the main script, so we don't need to load it separately.\n      ...without([\"en\"], translations || []).map(\n        (translation) => createCustomCdnUrl(\"ckbox\", `translations/${translation}.js`, version)\n      )\n    ],\n    // Load optional theme, if provided. It's not required but recommended because it improves the look and feel.\n    ...theme && {\n      stylesheets: [\n        createCustomCdnUrl(\"ckbox\", `styles/themes/${theme}.css`, version)\n      ]\n    },\n    // Pick the exported global variables from the window object.\n    checkPluginLoaded: async () => waitForWindowEntry([\"CKBox\"]),\n    // Check if the CKBox bundle is already loaded and throw an error if it is.\n    beforeInject: () => {\n      const installationInfo = getCKBoxInstallationInfo();\n      if (installationInfo && installationInfo.version !== version) {\n        throw new Error(\n          `CKBox is already loaded from CDN in version ${installationInfo.version}. Remove the old <script> and <link> tags loading CKBox to allow loading the ${version} version.`\n        );\n      }\n    }\n  };\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction isCKCdnSupportedByEditorVersion(version) {\n  if (isCKCdnTestingVersion(version)) {\n    return true;\n  }\n  const { major } = destructureSemanticVersion(version);\n  const licenseVersion = getLicenseVersionFromEditorVersion(version);\n  switch (licenseVersion) {\n    case 3:\n      return true;\n    default:\n      return major === 43;\n  }\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction combineCdnPluginsPacks(pluginsPacks) {\n  const normalizedPluginsPacks = mapObjectValues(pluginsPacks, (pluginPack, pluginName) => {\n    if (!pluginPack) {\n      return void 0;\n    }\n    const normalizedPluginPack = normalizeCKCdnResourcesPack(pluginPack);\n    return {\n      // Provide default window accessor object if the plugin pack does not define it.\n      checkPluginLoaded: async () => waitForWindowEntry([pluginName]),\n      // Transform the plugin pack to a normalized advanced pack.\n      ...normalizedPluginPack\n    };\n  });\n  return combineCKCdnBundlesPacks(\n    normalizedPluginsPacks\n  );\n}\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction loadCKEditorCloud(config) {\n  const {\n    version,\n    translations,\n    plugins,\n    premium,\n    ckbox,\n    createCustomCdnUrl,\n    injectedHtmlElementsAttributes = {\n      crossorigin: \"anonymous\"\n    }\n  } = config;\n  validateCKEditorVersion(version);\n  const pack = combineCKCdnBundlesPacks({\n    CKEditor: createCKCdnBaseBundlePack({\n      version,\n      translations,\n      createCustomCdnUrl\n    }),\n    ...premium && {\n      CKEditorPremiumFeatures: createCKCdnPremiumBundlePack({\n        version,\n        translations,\n        createCustomCdnUrl\n      })\n    },\n    ...ckbox && {\n      CKBox: createCKBoxBundlePack(ckbox)\n    },\n    loadedPlugins: combineCdnPluginsPacks(plugins ?? {})\n  });\n  return loadCKCdnResourcesPack(\n    {\n      ...pack,\n      htmlAttributes: injectedHtmlElementsAttributes\n    }\n  );\n}\nfunction validateCKEditorVersion(version) {\n  if (isCKCdnTestingVersion(version)) {\n    console.warn(\n      \"You are using a testing version of CKEditor 5. Please remember that it is not suitable for production environments.\"\n    );\n  }\n  if (!isCKCdnSupportedByEditorVersion(version)) {\n    throw new Error(\n      `The CKEditor 5 CDN can't be used with the given editor version: ${version}. Please make sure you are using at least the CKEditor 5 version 44.`\n    );\n  }\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2tlZGl0b3IvY2tlZGl0b3I1LWludGVncmF0aW9ucy1jb21tb24vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYSxJQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxJQUFJO0FBQ3BFO0FBQ0EsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxLQUFLO0FBQ3hFO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYSxJQUFJO0FBQ2pELGdEQUFnRCxJQUFJO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMscUJBQXFCO0FBQzlEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxxQkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Qsa0NBQWtDLGdCQUFnQjtBQUNsRCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVcsR0FBRyxPQUFPLEdBQUcsUUFBUSxHQUFHLEtBQUs7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjLEdBQUcsT0FBTyxHQUFHLFFBQVEsR0FBRyxLQUFLO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWSxHQUFHLFFBQVEsR0FBRyxLQUFLO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsWUFBWTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSx5QkFBeUIsb0ZBQW9GLFNBQVM7QUFDeEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixZQUFZO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFlBQVk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxNQUFNO0FBQzNEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHlCQUF5QiwrRUFBK0UsU0FBUztBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdURBQXVEO0FBQ3ZELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsUUFBUTtBQUNqRjtBQUNBO0FBQ0E7O0FBRXdlO0FBQ3hlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2tlZGl0b3IvY2tlZGl0b3I1LWludGVncmF0aW9ucy1jb21tb24vZGlzdC9pbmRleC5qcz9jNDNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVmZXIoKSB7XG4gIGNvbnN0IGRlZmVycmVkID0ge1xuICAgIHJlc29sdmU6IG51bGwsXG4gICAgcHJvbWlzZTogbnVsbFxuICB9O1xuICBkZWZlcnJlZC5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBkZWZlcnJlZC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgfSk7XG4gIHJldHVybiBkZWZlcnJlZDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyNSwgQ0tTb3VyY2UgSG9sZGluZyBzcC4geiBvLm8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1saWNlbnNpbmctb3B0aW9uc1xuICovXG5mdW5jdGlvbiB3YWl0Rm9yKGNhbGxiYWNrLCB7XG4gIHRpbWVPdXRBZnRlciA9IDUwMCxcbiAgcmV0cnlBZnRlciA9IDEwMFxufSA9IHt9KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgbGFzdEVycm9yID0gbnVsbDtcbiAgICBjb25zdCB0aW1lb3V0VGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVqZWN0KGxhc3RFcnJvciA/PyBuZXcgRXJyb3IoXCJUaW1lb3V0XCIpKTtcbiAgICB9LCB0aW1lT3V0QWZ0ZXIpO1xuICAgIGNvbnN0IHRpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWxsYmFjaygpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVySWQpO1xuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbGFzdEVycm9yID0gZXJyO1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA+IHRpbWVPdXRBZnRlcikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFRpbWVvdXQodGljaywgcmV0cnlBZnRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRpY2soKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuY29uc3QgSU5KRUNURURfU0NSSVBUUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBpbmplY3RTY3JpcHQoc3JjLCB7IGF0dHJpYnV0ZXMgfSA9IHt9KSB7XG4gIGlmIChJTkpFQ1RFRF9TQ1JJUFRTLmhhcyhzcmMpKSB7XG4gICAgcmV0dXJuIElOSkVDVEVEX1NDUklQVFMuZ2V0KHNyYyk7XG4gIH1cbiAgY29uc3QgbWF5YmVQcmV2U2NyaXB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc2NyaXB0W3NyYz1cIiR7c3JjfVwiXWApO1xuICBpZiAobWF5YmVQcmV2U2NyaXB0KSB7XG4gICAgY29uc29sZS53YXJuKGBTY3JpcHQgd2l0aCBcIiR7c3JjfVwiIHNyYyBpcyBhbHJlYWR5IHByZXNlbnQgaW4gRE9NIWApO1xuICAgIG1heWJlUHJldlNjcmlwdC5yZW1vdmUoKTtcbiAgfVxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgc2NyaXB0Lm9uZXJyb3IgPSByZWplY3Q7XG4gICAgc2NyaXB0Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMgfHwge30pKSB7XG4gICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBzY3JpcHQuc2V0QXR0cmlidXRlKFwiZGF0YS1pbmplY3RlZC1ieVwiLCBcImNrZWRpdG9yLWludGVncmF0aW9uXCIpO1xuICAgIHNjcmlwdC50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgIHNjcmlwdC5zcmMgPSBzcmM7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgY29uc3QgcmVtb3ZlZE5vZGVzID0gbXV0YXRpb25zLmZsYXRNYXAoKG11dGF0aW9uKSA9PiBBcnJheS5mcm9tKG11dGF0aW9uLnJlbW92ZWROb2RlcykpO1xuICAgICAgaWYgKHJlbW92ZWROb2Rlcy5pbmNsdWRlcyhzY3JpcHQpKSB7XG4gICAgICAgIElOSkVDVEVEX1NDUklQVFMuZGVsZXRlKHNyYyk7XG4gICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmhlYWQsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIHN1YnRyZWU6IHRydWVcbiAgICB9KTtcbiAgfSk7XG4gIElOSkVDVEVEX1NDUklQVFMuc2V0KHNyYywgcHJvbWlzZSk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuYXN5bmMgZnVuY3Rpb24gaW5qZWN0U2NyaXB0c0luUGFyYWxsZWwoc291cmNlcywgcHJvcHMpIHtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgc291cmNlcy5tYXAoKHNyYykgPT4gaW5qZWN0U2NyaXB0KHNyYywgcHJvcHMpKVxuICApO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmNvbnN0IElOSkVDVEVEX1NUWUxFU0hFRVRTID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGluamVjdFN0eWxlc2hlZXQoe1xuICBocmVmLFxuICBwbGFjZW1lbnRJbkhlYWQgPSBcInN0YXJ0XCIsXG4gIGF0dHJpYnV0ZXMgPSB7fVxufSkge1xuICBpZiAoSU5KRUNURURfU1RZTEVTSEVFVFMuaGFzKGhyZWYpKSB7XG4gICAgcmV0dXJuIElOSkVDVEVEX1NUWUxFU0hFRVRTLmdldChocmVmKTtcbiAgfVxuICBjb25zdCBtYXliZVByZXZTdHlsZXNoZWV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgbGlua1tocmVmPVwiJHtocmVmfVwiXVtyZWw9XCJzdHlsZXNoZWV0XCJdYCk7XG4gIGlmIChtYXliZVByZXZTdHlsZXNoZWV0KSB7XG4gICAgY29uc29sZS53YXJuKGBTdHlsZXNoZWV0IHdpdGggXCIke2hyZWZ9XCIgaHJlZiBpcyBhbHJlYWR5IHByZXNlbnQgaW4gRE9NIWApO1xuICAgIG1heWJlUHJldlN0eWxlc2hlZXQucmVtb3ZlKCk7XG4gIH1cbiAgY29uc3QgYXBwZW5kTGlua1RhZ1RvSGVhZCA9IChsaW5rKSA9PiB7XG4gICAgY29uc3QgcHJldmlvdXNseUluamVjdGVkTGlua3MgPSBBcnJheS5mcm9tKFxuICAgICAgZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rW2RhdGEtaW5qZWN0ZWQtYnk9XCJja2VkaXRvci1pbnRlZ3JhdGlvblwiXScpXG4gICAgKTtcbiAgICBzd2l0Y2ggKHBsYWNlbWVudEluSGVhZCkge1xuICAgICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICAgIGlmIChwcmV2aW91c2x5SW5qZWN0ZWRMaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICBwcmV2aW91c2x5SW5qZWN0ZWRMaW5rcy5zbGljZSgtMSlbMF0uYWZ0ZXIobGluayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9jdW1lbnQuaGVhZC5pbnNlcnRCZWZvcmUobGluaywgZG9jdW1lbnQuaGVhZC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzIHx8IHt9KSkge1xuICAgICAgbGluay5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGxpbmsuc2V0QXR0cmlidXRlKFwiZGF0YS1pbmplY3RlZC1ieVwiLCBcImNrZWRpdG9yLWludGVncmF0aW9uXCIpO1xuICAgIGxpbmsucmVsID0gXCJzdHlsZXNoZWV0XCI7XG4gICAgbGluay5ocmVmID0gaHJlZjtcbiAgICBsaW5rLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgbGluay5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICBhcHBlbmRMaW5rVGFnVG9IZWFkKGxpbmspO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgY29uc3QgcmVtb3ZlZE5vZGVzID0gbXV0YXRpb25zLmZsYXRNYXAoKG11dGF0aW9uKSA9PiBBcnJheS5mcm9tKG11dGF0aW9uLnJlbW92ZWROb2RlcykpO1xuICAgICAgaWYgKHJlbW92ZWROb2Rlcy5pbmNsdWRlcyhsaW5rKSkge1xuICAgICAgICBJTkpFQ1RFRF9TVFlMRVNIRUVUUy5kZWxldGUoaHJlZik7XG4gICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmhlYWQsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIHN1YnRyZWU6IHRydWVcbiAgICB9KTtcbiAgfSk7XG4gIElOSkVDVEVEX1NUWUxFU0hFRVRTLnNldChocmVmLCBwcm9taXNlKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gaXNTU1IoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgbGV0IGxhc3RSZXN1bHQgPSBudWxsO1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoIWxhc3RSZXN1bHQpIHtcbiAgICAgIGxhc3RSZXN1bHQgPSB7XG4gICAgICAgIGN1cnJlbnQ6IGZuKC4uLmFyZ3MpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbGFzdFJlc3VsdC5jdXJyZW50O1xuICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmZ1bmN0aW9uIG92ZXJ3cml0ZUFycmF5KHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgZGVzdGluYXRpb24ubGVuZ3RoID0gMDtcbiAgZGVzdGluYXRpb24ucHVzaCguLi5zb3VyY2UpO1xuICByZXR1cm4gZGVzdGluYXRpb247XG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gb3ZlcndyaXRlT2JqZWN0KHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgZm9yIChjb25zdCBwcm9wIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlc3RpbmF0aW9uKSkge1xuICAgIGRlbGV0ZSBkZXN0aW5hdGlvbltwcm9wXTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG4gICAgaWYgKHZhbHVlICE9PSBkZXN0aW5hdGlvbiAmJiBrZXkgIT09IFwicHJvdG90eXBlXCIgJiYga2V5ICE9PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICBkZXN0aW5hdGlvbltrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXN0aW5hdGlvbjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyNSwgQ0tTb3VyY2UgSG9sZGluZyBzcC4geiBvLm8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1saWNlbnNpbmctb3B0aW9uc1xuICovXG5mdW5jdGlvbiBwcmVsb2FkUmVzb3VyY2UodXJsLCB7IGF0dHJpYnV0ZXMgfSA9IHt9KSB7XG4gIGlmIChkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoYGxpbmtbaHJlZj1cIiR7dXJsfVwiXVtyZWw9XCJwcmVsb2FkXCJdYCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzIHx8IHt9KSkge1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICB9XG4gIGxpbmsuc2V0QXR0cmlidXRlKFwiZGF0YS1pbmplY3RlZC1ieVwiLCBcImNrZWRpdG9yLWludGVncmF0aW9uXCIpO1xuICBsaW5rLnJlbCA9IFwicHJlbG9hZFwiO1xuICBsaW5rLmFzID0gZGV0ZWN0VHlwZU9mUmVzb3VyY2UodXJsKTtcbiAgbGluay5ocmVmID0gdXJsO1xuICBkb2N1bWVudC5oZWFkLmluc2VydEJlZm9yZShsaW5rLCBkb2N1bWVudC5oZWFkLmZpcnN0Q2hpbGQpO1xufVxuZnVuY3Rpb24gZGV0ZWN0VHlwZU9mUmVzb3VyY2UodXJsKSB7XG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2UgL1xcLmNzcyQvLnRlc3QodXJsKTpcbiAgICAgIHJldHVybiBcInN0eWxlXCI7XG4gICAgY2FzZSAvXFwuanMkLy50ZXN0KHVybCk6XG4gICAgICByZXR1cm4gXCJzY3JpcHRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiZmV0Y2hcIjtcbiAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dDb21wYXJlQXJyYXlzKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWEgfHwgIWIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuY29uc3QgSEVYX05VTUJFUlMgPSBuZXcgQXJyYXkoMjU2KS5maWxsKFwiXCIpLm1hcCgoXywgaW5kZXgpID0+IChcIjBcIiArIGluZGV4LnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpKTtcbmZ1bmN0aW9uIHVpZCgpIHtcbiAgY29uc3QgW3IxLCByMiwgcjMsIHI0XSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDQpKTtcbiAgcmV0dXJuIFwiZVwiICsgSEVYX05VTUJFUlNbcjEgPj4gMCAmIDI1NV0gKyBIRVhfTlVNQkVSU1tyMSA+PiA4ICYgMjU1XSArIEhFWF9OVU1CRVJTW3IxID4+IDE2ICYgMjU1XSArIEhFWF9OVU1CRVJTW3IxID4+IDI0ICYgMjU1XSArIEhFWF9OVU1CRVJTW3IyID4+IDAgJiAyNTVdICsgSEVYX05VTUJFUlNbcjIgPj4gOCAmIDI1NV0gKyBIRVhfTlVNQkVSU1tyMiA+PiAxNiAmIDI1NV0gKyBIRVhfTlVNQkVSU1tyMiA+PiAyNCAmIDI1NV0gKyBIRVhfTlVNQkVSU1tyMyA+PiAwICYgMjU1XSArIEhFWF9OVU1CRVJTW3IzID4+IDggJiAyNTVdICsgSEVYX05VTUJFUlNbcjMgPj4gMTYgJiAyNTVdICsgSEVYX05VTUJFUlNbcjMgPj4gMjQgJiAyNTVdICsgSEVYX05VTUJFUlNbcjQgPj4gMCAmIDI1NV0gKyBIRVhfTlVNQkVSU1tyNCA+PiA4ICYgMjU1XSArIEhFWF9OVU1CRVJTW3I0ID4+IDE2ICYgMjU1XSArIEhFWF9OVU1CRVJTW3I0ID4+IDI0ICYgMjU1XTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyNSwgQ0tTb3VyY2UgSG9sZGluZyBzcC4geiBvLm8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1saWNlbnNpbmctb3B0aW9uc1xuICovXG5mdW5jdGlvbiB1bmlxKHNvdXJjZSkge1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KHNvdXJjZSkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JXaW5kb3dFbnRyeShlbnRyeU5hbWVzLCBjb25maWcpIHtcbiAgY29uc3QgdHJ5UGlja0J1bmRsZSA9ICgpID0+IGVudHJ5TmFtZXMubWFwKChuYW1lKSA9PiB3aW5kb3dbbmFtZV0pLmZpbHRlcihCb29sZWFuKVswXTtcbiAgcmV0dXJuIHdhaXRGb3IoXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdHJ5UGlja0J1bmRsZSgpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaW5kb3cgZW50cnkgXCIke2VudHJ5TmFtZXMuam9pbihcIixcIil9XCIgbm90IGZvdW5kLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIGNvbmZpZ1xuICApO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGZpbHRlck9iamVjdFZhbHVlcyhvYmosIGZpbHRlcikge1xuICBjb25zdCBmaWx0ZXJlZEVudHJpZXMgPSBPYmplY3QuZW50cmllcyhvYmopLmZpbHRlcigoW2tleSwgdmFsdWVdKSA9PiBmaWx0ZXIodmFsdWUsIGtleSkpO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGZpbHRlcmVkRW50cmllcyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZmlsdGVyQmxhbmtPYmplY3RWYWx1ZXMob2JqKSB7XG4gIHJldHVybiBmaWx0ZXJPYmplY3RWYWx1ZXMoXG4gICAgb2JqLFxuICAgICh2YWx1ZSkgPT4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMFxuICApO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmZ1bmN0aW9uIG1hcE9iamVjdFZhbHVlcyhvYmosIG1hcHBlcikge1xuICBjb25zdCBtYXBwZWRFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMob2JqKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleSwgbWFwcGVyKHZhbHVlLCBrZXkpXSk7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMobWFwcGVkRW50cmllcyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gd2l0aG91dChpdGVtc1RvUmVtb3ZlLCBpdGVtcykge1xuICByZXR1cm4gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiAhaXRlbXNUb1JlbW92ZS5pbmNsdWRlcyhpdGVtKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwZW5kRXh0cmFQbHVnaW5zVG9FZGl0b3JDb25maWcoY29uZmlnLCBwbHVnaW5zKSB7XG4gIGNvbnN0IGV4dHJhUGx1Z2lucyA9IGNvbmZpZy5leHRyYVBsdWdpbnMgfHwgW107XG4gIHJldHVybiB7XG4gICAgLi4uY29uZmlnLFxuICAgIGV4dHJhUGx1Z2luczogW1xuICAgICAgLi4uZXh0cmFQbHVnaW5zLFxuICAgICAgLi4ucGx1Z2lucy5maWx0ZXIoKGl0ZW0pID0+ICFleHRyYVBsdWdpbnMuaW5jbHVkZXMoaXRlbSkpXG4gICAgXVxuICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGlzU2VtYW50aWNWZXJzaW9uKHZlcnNpb24pIHtcbiAgcmV0dXJuICEhdmVyc2lvbiAmJiAvXlxcZCtcXC5cXGQrXFwuXFxkKy8udGVzdCh2ZXJzaW9uKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyNSwgQ0tTb3VyY2UgSG9sZGluZyBzcC4geiBvLm8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1saWNlbnNpbmctb3B0aW9uc1xuICovXG5mdW5jdGlvbiBpc0NLQ2RuVGVzdGluZ1ZlcnNpb24odmVyc2lvbikge1xuICBpZiAoIXZlcnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIFtcIm5pZ2h0bHlcIiwgXCJhbHBoYVwiLCBcImludGVybmFsXCIsIFwibmlnaHRseS1cIiwgXCJzdGFnaW5nXCJdLnNvbWUoKHRlc3RWZXJzaW9uKSA9PiB2ZXJzaW9uLmluY2x1ZGVzKHRlc3RWZXJzaW9uKSk7XG59XG5mdW5jdGlvbiBpc0NLQ2RuVmVyc2lvbih2ZXJzaW9uKSB7XG4gIHJldHVybiBpc1NlbWFudGljVmVyc2lvbih2ZXJzaW9uKSB8fCBpc0NLQ2RuVGVzdGluZ1ZlcnNpb24odmVyc2lvbik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVTZW1hbnRpY1ZlcnNpb24odmVyc2lvbikge1xuICBpZiAoIWlzU2VtYW50aWNWZXJzaW9uKHZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlbWFudGljIHZlcnNpb246ICR7dmVyc2lvbiB8fCBcIjxibGFuaz5cIn0uYCk7XG4gIH1cbiAgY29uc3QgW21ham9yLCBtaW5vciwgcGF0Y2hdID0gdmVyc2lvbi5zcGxpdChcIi5cIik7XG4gIHJldHVybiB7XG4gICAgbWFqb3I6IE51bWJlci5wYXJzZUludChtYWpvciwgMTApLFxuICAgIG1pbm9yOiBOdW1iZXIucGFyc2VJbnQobWlub3IsIDEwKSxcbiAgICBwYXRjaDogTnVtYmVyLnBhcnNlSW50KHBhdGNoLCAxMClcbiAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyNSwgQ0tTb3VyY2UgSG9sZGluZyBzcC4geiBvLm8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1saWNlbnNpbmctb3B0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRMaWNlbnNlVmVyc2lvbkZyb21FZGl0b3JWZXJzaW9uKHZlcnNpb24pIHtcbiAgaWYgKGlzQ0tDZG5UZXN0aW5nVmVyc2lvbih2ZXJzaW9uKSkge1xuICAgIHJldHVybiAzO1xuICB9XG4gIGNvbnN0IHsgbWFqb3IgfSA9IGRlc3RydWN0dXJlU2VtYW50aWNWZXJzaW9uKHZlcnNpb24pO1xuICBzd2l0Y2ggKHRydWUpIHtcbiAgICBjYXNlIG1ham9yID49IDQ0OlxuICAgICAgcmV0dXJuIDM7XG4gICAgY2FzZSBtYWpvciA+PSAzODpcbiAgICAgIHJldHVybiAyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMTtcbiAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldENLQmFzZUJ1bmRsZUluc3RhbGxhdGlvbkluZm8oKSB7XG4gIGNvbnN0IHsgQ0tFRElUT1JfVkVSU0lPTiwgQ0tFRElUT1IgfSA9IHdpbmRvdztcbiAgaWYgKCFpc0NLQ2RuVmVyc2lvbihDS0VESVRPUl9WRVJTSU9OKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgc291cmNlOiBDS0VESVRPUiA/IFwiY2RuXCIgOiBcIm5wbVwiLFxuICAgIHZlcnNpb246IENLRURJVE9SX1ZFUlNJT05cbiAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyNSwgQ0tTb3VyY2UgSG9sZGluZyBzcC4geiBvLm8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1saWNlbnNpbmctb3B0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRMaWNlbnNlVmVyc2lvbkluc3RhbGxhdGlvbkluZm8oKSB7XG4gIGNvbnN0IGluc3RhbGxhdGlvbkluZm8gPSBnZXRDS0Jhc2VCdW5kbGVJbnN0YWxsYXRpb25JbmZvKCk7XG4gIGlmICghaW5zdGFsbGF0aW9uSW5mbykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBnZXRMaWNlbnNlVmVyc2lvbkZyb21FZGl0b3JWZXJzaW9uKGluc3RhbGxhdGlvbkluZm8udmVyc2lvbik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gaXNDS0VkaXRvckZyZWVMaWNlbnNlKGxpY2Vuc2VLZXksIGxpY2Vuc2VWZXJzaW9uKSB7XG4gIGxpY2Vuc2VWZXJzaW9uIHx8PSBnZXRTdXBwb3J0ZWRMaWNlbnNlVmVyc2lvbkluc3RhbGxhdGlvbkluZm8oKSB8fCB2b2lkIDA7XG4gIHN3aXRjaCAobGljZW5zZVZlcnNpb24pIHtcbiAgICBjYXNlIDE6XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGxpY2Vuc2VLZXkgPT09IHZvaWQgMDtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gbGljZW5zZUtleSA9PT0gXCJHUExcIjtcbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW50ZWdyYXRpb25Vc2FnZURhdGFQbHVnaW4oaW50ZWdyYXRpb25OYW1lLCB1c2FnZURhdGEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludGVncmF0aW9uVXNhZ2VEYXRhUGx1Z2luKGVkaXRvcikge1xuICAgIGlmIChpc0NLRWRpdG9yRnJlZUxpY2Vuc2UoZWRpdG9yLmNvbmZpZy5nZXQoXCJsaWNlbnNlS2V5XCIpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZGl0b3Iub24oXCJjb2xsZWN0VXNhZ2VEYXRhXCIsIChzb3VyY2UsIHsgc2V0VXNhZ2VEYXRhIH0pID0+IHtcbiAgICAgIHNldFVzYWdlRGF0YShgaW50ZWdyYXRpb24uJHtpbnRlZ3JhdGlvbk5hbWV9YCwgdXNhZ2VEYXRhKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyNSwgQ0tTb3VyY2UgSG9sZGluZyBzcC4geiBvLm8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1saWNlbnNpbmctb3B0aW9uc1xuICovXG5jb25zdCBDS19DRE5fVVJMID0gXCJodHRwczovL2Nkbi5ja2VkaXRvci5jb21cIjtcbmZ1bmN0aW9uIGNyZWF0ZUNLQ2RuVXJsKGJ1bmRsZSwgZmlsZSwgdmVyc2lvbikge1xuICByZXR1cm4gYCR7Q0tfQ0ROX1VSTH0vJHtidW5kbGV9LyR7dmVyc2lvbn0vJHtmaWxlfWA7XG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuY29uc3QgQ0tCT1hfQ0ROX1VSTCA9IFwiaHR0cHM6Ly9jZG4uY2tib3guaW9cIjtcbmZ1bmN0aW9uIGNyZWF0ZUNLQm94Q2RuVXJsKGJ1bmRsZSwgZmlsZSwgdmVyc2lvbikge1xuICByZXR1cm4gYCR7Q0tCT1hfQ0ROX1VSTH0vJHtidW5kbGV9LyR7dmVyc2lvbn0vJHtmaWxlfWA7XG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuY29uc3QgQ0tfRE9DU19VUkwgPSBcImh0dHBzOi8vY2tlZGl0b3IuY29tL2RvY3MvY2tlZGl0b3I1XCI7XG5mdW5jdGlvbiBjcmVhdGVDS0RvY3NVcmwocGF0aCwgdmVyc2lvbiA9IFwibGF0ZXN0XCIpIHtcbiAgcmV0dXJuIGAke0NLX0RPQ1NfVVJMfS8ke3ZlcnNpb259LyR7cGF0aH1gO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNLQ2RuQmFzZUJ1bmRsZVBhY2soe1xuICB2ZXJzaW9uLFxuICB0cmFuc2xhdGlvbnMsXG4gIGNyZWF0ZUN1c3RvbUNkblVybCA9IGNyZWF0ZUNLQ2RuVXJsXG59KSB7XG4gIGNvbnN0IHVybHMgPSB7XG4gICAgc2NyaXB0czogW1xuICAgICAgLy8gTG9hZCB0aGUgbWFpbiBzY3JpcHQgb2YgdGhlIGJhc2UgZmVhdHVyZXMuXG4gICAgICBjcmVhdGVDdXN0b21DZG5VcmwoXCJja2VkaXRvcjVcIiwgXCJja2VkaXRvcjUudW1kLmpzXCIsIHZlcnNpb24pLFxuICAgICAgLy8gTG9hZCBhbGwgSmF2YVNjcmlwdCBmaWxlcyBmcm9tIHRoZSBiYXNlIGZlYXR1cmVzLlxuICAgICAgLy8gRU4gYnVuZGxlIGlzIHByZWJ1aWx0IGludG8gdGhlIG1haW4gc2NyaXB0LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGxvYWQgaXQgc2VwYXJhdGVseS5cbiAgICAgIC4uLndpdGhvdXQoW1wiZW5cIl0sIHRyYW5zbGF0aW9ucyB8fCBbXSkubWFwKFxuICAgICAgICAodHJhbnNsYXRpb24pID0+IGNyZWF0ZUN1c3RvbUNkblVybChcImNrZWRpdG9yNVwiLCBgdHJhbnNsYXRpb25zLyR7dHJhbnNsYXRpb259LnVtZC5qc2AsIHZlcnNpb24pXG4gICAgICApXG4gICAgXSxcbiAgICBzdHlsZXNoZWV0czogW1xuICAgICAgY3JlYXRlQ3VzdG9tQ2RuVXJsKFwiY2tlZGl0b3I1XCIsIFwiY2tlZGl0b3I1LmNzc1wiLCB2ZXJzaW9uKVxuICAgIF1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICAvLyBQcmVsb2FkIHJlc291cmNlcyBzcGVjaWZpZWQgaW4gdGhlIHBhY2ssIGJlZm9yZSBsb2FkaW5nIHRoZSBtYWluIHNjcmlwdC5cbiAgICBwcmVsb2FkOiBbXG4gICAgICAuLi51cmxzLnN0eWxlc2hlZXRzLFxuICAgICAgLi4udXJscy5zY3JpcHRzXG4gICAgXSxcbiAgICBzY3JpcHRzOiBbXG4gICAgICAvLyBJdCdzIHNhZmUgdG8gbG9hZCB0cmFuc2xhdGlvbnMgYW5kIHRoZSBtYWluIHNjcmlwdCBpbiBwYXJhbGxlbC5cbiAgICAgIGFzeW5jIChhdHRyaWJ1dGVzKSA9PiBpbmplY3RTY3JpcHRzSW5QYXJhbGxlbCh1cmxzLnNjcmlwdHMsIGF0dHJpYnV0ZXMpXG4gICAgXSxcbiAgICAvLyBMb2FkIGFsbCBzdHlsZXNoZWV0cyBvZiB0aGUgYmFzZSBmZWF0dXJlcy5cbiAgICBzdHlsZXNoZWV0czogdXJscy5zdHlsZXNoZWV0cyxcbiAgICAvLyBQaWNrIHRoZSBleHBvcnRlZCBnbG9iYWwgdmFyaWFibGVzIGZyb20gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgY2hlY2tQbHVnaW5Mb2FkZWQ6IGFzeW5jICgpID0+IHdhaXRGb3JXaW5kb3dFbnRyeShbXCJDS0VESVRPUlwiXSksXG4gICAgLy8gQ2hlY2sgaWYgdGhlIENLRWRpdG9yIGJhc2UgYnVuZGxlIGlzIGFscmVhZHkgbG9hZGVkIGFuZCB0aHJvdyBhbiBlcnJvciBpZiBpdCBpcy5cbiAgICBiZWZvcmVJbmplY3Q6ICgpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbGxhdGlvbkluZm8gPSBnZXRDS0Jhc2VCdW5kbGVJbnN0YWxsYXRpb25JbmZvKCk7XG4gICAgICBzd2l0Y2ggKGluc3RhbGxhdGlvbkluZm8/LnNvdXJjZSkge1xuICAgICAgICBjYXNlIFwibnBtXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJDS0VkaXRvciA1IGlzIGFscmVhZHkgbG9hZGVkIGZyb20gbnBtLiBDaGVjayB0aGUgbWlncmF0aW9uIGd1aWRlIGZvciBtb3JlIGRldGFpbHM6IFwiICsgY3JlYXRlQ0tEb2NzVXJsKFwidXBkYXRpbmcvbWlncmF0aW9uLXRvLWNkbi92YW5pbGxhLWpzLmh0bWxcIilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiY2RuXCI6XG4gICAgICAgICAgaWYgKGluc3RhbGxhdGlvbkluZm8udmVyc2lvbiAhPT0gdmVyc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgQ0tFZGl0b3IgNSBpcyBhbHJlYWR5IGxvYWRlZCBmcm9tIENETiBpbiB2ZXJzaW9uICR7aW5zdGFsbGF0aW9uSW5mby52ZXJzaW9ufS4gUmVtb3ZlIHRoZSBvbGQgPHNjcmlwdD4gYW5kIDxsaW5rPiB0YWdzIGxvYWRpbmcgQ0tFZGl0b3IgNSB0byBhbGxvdyBsb2FkaW5nIHRoZSAke3ZlcnNpb259IHZlcnNpb24uYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNLQ2RuUHJlbWl1bUJ1bmRsZVBhY2soe1xuICB2ZXJzaW9uLFxuICB0cmFuc2xhdGlvbnMsXG4gIGNyZWF0ZUN1c3RvbUNkblVybCA9IGNyZWF0ZUNLQ2RuVXJsXG59KSB7XG4gIGNvbnN0IHVybHMgPSB7XG4gICAgc2NyaXB0czogW1xuICAgICAgLy8gTG9hZCB0aGUgbWFpbiBzY3JpcHQgb2YgdGhlIHByZW1pdW0gZmVhdHVyZXMuXG4gICAgICBjcmVhdGVDdXN0b21DZG5VcmwoXCJja2VkaXRvcjUtcHJlbWl1bS1mZWF0dXJlc1wiLCBcImNrZWRpdG9yNS1wcmVtaXVtLWZlYXR1cmVzLnVtZC5qc1wiLCB2ZXJzaW9uKSxcbiAgICAgIC8vIExvYWQgYWxsIEphdmFTY3JpcHQgZmlsZXMgZnJvbSB0aGUgcHJlbWl1bSBmZWF0dXJlcy5cbiAgICAgIC8vIEVOIGJ1bmRsZSBpcyBwcmVidWlsdCBpbnRvIHRoZSBtYWluIHNjcmlwdCwgc28gd2UgZG9uJ3QgbmVlZCB0byBsb2FkIGl0IHNlcGFyYXRlbHkuXG4gICAgICAuLi53aXRob3V0KFtcImVuXCJdLCB0cmFuc2xhdGlvbnMgfHwgW10pLm1hcChcbiAgICAgICAgKHRyYW5zbGF0aW9uKSA9PiBjcmVhdGVDdXN0b21DZG5VcmwoXCJja2VkaXRvcjUtcHJlbWl1bS1mZWF0dXJlc1wiLCBgdHJhbnNsYXRpb25zLyR7dHJhbnNsYXRpb259LnVtZC5qc2AsIHZlcnNpb24pXG4gICAgICApXG4gICAgXSxcbiAgICBzdHlsZXNoZWV0czogW1xuICAgICAgY3JlYXRlQ3VzdG9tQ2RuVXJsKFwiY2tlZGl0b3I1LXByZW1pdW0tZmVhdHVyZXNcIiwgXCJja2VkaXRvcjUtcHJlbWl1bS1mZWF0dXJlcy5jc3NcIiwgdmVyc2lvbilcbiAgICBdXG4gIH07XG4gIHJldHVybiB7XG4gICAgLy8gUHJlbG9hZCByZXNvdXJjZXMgc3BlY2lmaWVkIGluIHRoZSBwYWNrLCBiZWZvcmUgbG9hZGluZyB0aGUgbWFpbiBzY3JpcHQuXG4gICAgcHJlbG9hZDogW1xuICAgICAgLi4udXJscy5zdHlsZXNoZWV0cyxcbiAgICAgIC4uLnVybHMuc2NyaXB0c1xuICAgIF0sXG4gICAgc2NyaXB0czogW1xuICAgICAgLy8gSXQncyBzYWZlIHRvIGxvYWQgdHJhbnNsYXRpb25zIGFuZCB0aGUgbWFpbiBzY3JpcHQgaW4gcGFyYWxsZWwuXG4gICAgICBhc3luYyAoYXR0cmlidXRlcykgPT4gaW5qZWN0U2NyaXB0c0luUGFyYWxsZWwodXJscy5zY3JpcHRzLCBhdHRyaWJ1dGVzKVxuICAgIF0sXG4gICAgLy8gTG9hZCBhbGwgc3R5bGVzaGVldHMgb2YgdGhlIHByZW1pdW0gZmVhdHVyZXMuXG4gICAgc3R5bGVzaGVldHM6IHVybHMuc3R5bGVzaGVldHMsXG4gICAgLy8gUGljayB0aGUgZXhwb3J0ZWQgZ2xvYmFsIHZhcmlhYmxlcyBmcm9tIHRoZSB3aW5kb3cgb2JqZWN0LlxuICAgIGNoZWNrUGx1Z2luTG9hZGVkOiBhc3luYyAoKSA9PiB3YWl0Rm9yV2luZG93RW50cnkoW1wiQ0tFRElUT1JfUFJFTUlVTV9GRUFUVVJFU1wiXSlcbiAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyNSwgQ0tTb3VyY2UgSG9sZGluZyBzcC4geiBvLm8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1saWNlbnNpbmctb3B0aW9uc1xuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkQ0tDZG5SZXNvdXJjZXNQYWNrKHBhY2spIHtcbiAgbGV0IHtcbiAgICBodG1sQXR0cmlidXRlcyA9IHt9LFxuICAgIHNjcmlwdHMgPSBbXSxcbiAgICBzdHlsZXNoZWV0cyA9IFtdLFxuICAgIHByZWxvYWQsXG4gICAgYmVmb3JlSW5qZWN0LFxuICAgIGNoZWNrUGx1Z2luTG9hZGVkXG4gIH0gPSBub3JtYWxpemVDS0NkblJlc291cmNlc1BhY2socGFjayk7XG4gIGJlZm9yZUluamVjdD8uKCk7XG4gIGlmICghcHJlbG9hZCkge1xuICAgIHByZWxvYWQgPSB1bmlxKFtcbiAgICAgIC4uLnN0eWxlc2hlZXRzLmZpbHRlcigoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpLFxuICAgICAgLi4uc2NyaXB0cy5maWx0ZXIoKGl0ZW0pID0+IHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKVxuICAgIF0pO1xuICB9XG4gIGZvciAoY29uc3QgdXJsIG9mIHByZWxvYWQpIHtcbiAgICBwcmVsb2FkUmVzb3VyY2UodXJsLCB7XG4gICAgICBhdHRyaWJ1dGVzOiBodG1sQXR0cmlidXRlc1xuICAgIH0pO1xuICB9XG4gIGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHVuaXEoc3R5bGVzaGVldHMpLm1hcCgoaHJlZikgPT4gaW5qZWN0U3R5bGVzaGVldCh7XG4gICAgICBocmVmLFxuICAgICAgYXR0cmlidXRlczogaHRtbEF0dHJpYnV0ZXMsXG4gICAgICBwbGFjZW1lbnRJbkhlYWQ6IFwic3RhcnRcIlxuICAgIH0pKVxuICApO1xuICBmb3IgKGNvbnN0IHNjcmlwdCBvZiB1bmlxKHNjcmlwdHMpKSB7XG4gICAgY29uc3QgaW5qZWN0b3JQcm9wcyA9IHtcbiAgICAgIGF0dHJpYnV0ZXM6IGh0bWxBdHRyaWJ1dGVzXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHNjcmlwdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgYXdhaXQgaW5qZWN0U2NyaXB0KHNjcmlwdCwgaW5qZWN0b3JQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHNjcmlwdChpbmplY3RvclByb3BzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoZWNrUGx1Z2luTG9hZGVkPy4oKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNLQ2RuUmVzb3VyY2VzUGFjayhwYWNrKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhY2spKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmlwdHM6IHBhY2suZmlsdGVyKFxuICAgICAgICAoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIiB8fCBpdGVtLmVuZHNXaXRoKFwiLmpzXCIpXG4gICAgICApLFxuICAgICAgc3R5bGVzaGVldHM6IHBhY2suZmlsdGVyKFxuICAgICAgICAoaXRlbSkgPT4gaXRlbS5lbmRzV2l0aChcIi5jc3NcIilcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgcGFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoZWNrUGx1Z2luTG9hZGVkOiBwYWNrXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcGFjaztcbn1cblxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyNSwgQ0tTb3VyY2UgSG9sZGluZyBzcC4geiBvLm8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1saWNlbnNpbmctb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjb21iaW5lQ0tDZG5CdW5kbGVzUGFja3MocGFja3MpIHtcbiAgY29uc3Qgbm9ybWFsaXplZFBhY2tzID0gbWFwT2JqZWN0VmFsdWVzKFxuICAgIGZpbHRlckJsYW5rT2JqZWN0VmFsdWVzKHBhY2tzKSxcbiAgICBub3JtYWxpemVDS0NkblJlc291cmNlc1BhY2tcbiAgKTtcbiAgY29uc3QgbWVyZ2VkUGFja3MgPSBPYmplY3QudmFsdWVzKG5vcm1hbGl6ZWRQYWNrcykucmVkdWNlKFxuICAgIChhY2MsIHBhY2spID0+IHtcbiAgICAgIGFjYy5zY3JpcHRzLnB1c2goLi4ucGFjay5zY3JpcHRzID8/IFtdKTtcbiAgICAgIGFjYy5zdHlsZXNoZWV0cy5wdXNoKC4uLnBhY2suc3R5bGVzaGVldHMgPz8gW10pO1xuICAgICAgYWNjLnByZWxvYWQucHVzaCguLi5wYWNrLnByZWxvYWQgPz8gW10pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIHtcbiAgICAgIHByZWxvYWQ6IFtdLFxuICAgICAgc2NyaXB0czogW10sXG4gICAgICBzdHlsZXNoZWV0czogW11cbiAgICB9XG4gICk7XG4gIGNvbnN0IGNoZWNrUGx1Z2luTG9hZGVkID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGV4cG9ydGVkR2xvYmFsVmFyaWFibGVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgcGFja10gb2YgT2JqZWN0LmVudHJpZXMobm9ybWFsaXplZFBhY2tzKSkge1xuICAgICAgZXhwb3J0ZWRHbG9iYWxWYXJpYWJsZXNbbmFtZV0gPSBhd2FpdCBwYWNrPy5jaGVja1BsdWdpbkxvYWRlZD8uKCk7XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRlZEdsb2JhbFZhcmlhYmxlcztcbiAgfTtcbiAgY29uc3QgYmVmb3JlSW5qZWN0ID0gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgcGFjayBvZiBPYmplY3QudmFsdWVzKG5vcm1hbGl6ZWRQYWNrcykpIHtcbiAgICAgIHBhY2suYmVmb3JlSW5qZWN0Py4oKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgLi4ubWVyZ2VkUGFja3MsXG4gICAgYmVmb3JlSW5qZWN0LFxuICAgIGNoZWNrUGx1Z2luTG9hZGVkXG4gIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZ2V0Q0tCb3hJbnN0YWxsYXRpb25JbmZvKCkge1xuICBjb25zdCB2ZXJzaW9uID0gd2luZG93LkNLQm94Py52ZXJzaW9uO1xuICBpZiAoIWlzU2VtYW50aWNWZXJzaW9uKHZlcnNpb24pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzb3VyY2U6IFwiY2RuXCIsXG4gICAgdmVyc2lvblxuICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNLQm94QnVuZGxlUGFjayh7XG4gIHZlcnNpb24sXG4gIHRoZW1lID0gXCJsYXJrXCIsXG4gIHRyYW5zbGF0aW9ucyxcbiAgY3JlYXRlQ3VzdG9tQ2RuVXJsID0gY3JlYXRlQ0tCb3hDZG5Vcmxcbn0pIHtcbiAgcmV0dXJuIHtcbiAgICAvLyBMb2FkIHRoZSBtYWluIHNjcmlwdCBvZiB0aGUgYmFzZSBmZWF0dXJlcy5cbiAgICBzY3JpcHRzOiBbXG4gICAgICBjcmVhdGVDdXN0b21DZG5VcmwoXCJja2JveFwiLCBcImNrYm94LmpzXCIsIHZlcnNpb24pLFxuICAgICAgLy8gRU4gYnVuZGxlIGlzIHByZWJ1aWx0IGludG8gdGhlIG1haW4gc2NyaXB0LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGxvYWQgaXQgc2VwYXJhdGVseS5cbiAgICAgIC4uLndpdGhvdXQoW1wiZW5cIl0sIHRyYW5zbGF0aW9ucyB8fCBbXSkubWFwKFxuICAgICAgICAodHJhbnNsYXRpb24pID0+IGNyZWF0ZUN1c3RvbUNkblVybChcImNrYm94XCIsIGB0cmFuc2xhdGlvbnMvJHt0cmFuc2xhdGlvbn0uanNgLCB2ZXJzaW9uKVxuICAgICAgKVxuICAgIF0sXG4gICAgLy8gTG9hZCBvcHRpb25hbCB0aGVtZSwgaWYgcHJvdmlkZWQuIEl0J3Mgbm90IHJlcXVpcmVkIGJ1dCByZWNvbW1lbmRlZCBiZWNhdXNlIGl0IGltcHJvdmVzIHRoZSBsb29rIGFuZCBmZWVsLlxuICAgIC4uLnRoZW1lICYmIHtcbiAgICAgIHN0eWxlc2hlZXRzOiBbXG4gICAgICAgIGNyZWF0ZUN1c3RvbUNkblVybChcImNrYm94XCIsIGBzdHlsZXMvdGhlbWVzLyR7dGhlbWV9LmNzc2AsIHZlcnNpb24pXG4gICAgICBdXG4gICAgfSxcbiAgICAvLyBQaWNrIHRoZSBleHBvcnRlZCBnbG9iYWwgdmFyaWFibGVzIGZyb20gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgY2hlY2tQbHVnaW5Mb2FkZWQ6IGFzeW5jICgpID0+IHdhaXRGb3JXaW5kb3dFbnRyeShbXCJDS0JveFwiXSksXG4gICAgLy8gQ2hlY2sgaWYgdGhlIENLQm94IGJ1bmRsZSBpcyBhbHJlYWR5IGxvYWRlZCBhbmQgdGhyb3cgYW4gZXJyb3IgaWYgaXQgaXMuXG4gICAgYmVmb3JlSW5qZWN0OiAoKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YWxsYXRpb25JbmZvID0gZ2V0Q0tCb3hJbnN0YWxsYXRpb25JbmZvKCk7XG4gICAgICBpZiAoaW5zdGFsbGF0aW9uSW5mbyAmJiBpbnN0YWxsYXRpb25JbmZvLnZlcnNpb24gIT09IHZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDS0JveCBpcyBhbHJlYWR5IGxvYWRlZCBmcm9tIENETiBpbiB2ZXJzaW9uICR7aW5zdGFsbGF0aW9uSW5mby52ZXJzaW9ufS4gUmVtb3ZlIHRoZSBvbGQgPHNjcmlwdD4gYW5kIDxsaW5rPiB0YWdzIGxvYWRpbmcgQ0tCb3ggdG8gYWxsb3cgbG9hZGluZyB0aGUgJHt2ZXJzaW9ufSB2ZXJzaW9uLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gaXNDS0NkblN1cHBvcnRlZEJ5RWRpdG9yVmVyc2lvbih2ZXJzaW9uKSB7XG4gIGlmIChpc0NLQ2RuVGVzdGluZ1ZlcnNpb24odmVyc2lvbikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB7IG1ham9yIH0gPSBkZXN0cnVjdHVyZVNlbWFudGljVmVyc2lvbih2ZXJzaW9uKTtcbiAgY29uc3QgbGljZW5zZVZlcnNpb24gPSBnZXRMaWNlbnNlVmVyc2lvbkZyb21FZGl0b3JWZXJzaW9uKHZlcnNpb24pO1xuICBzd2l0Y2ggKGxpY2Vuc2VWZXJzaW9uKSB7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBtYWpvciA9PT0gNDM7XG4gIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyNSwgQ0tTb3VyY2UgSG9sZGluZyBzcC4geiBvLm8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1saWNlbnNpbmctb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjb21iaW5lQ2RuUGx1Z2luc1BhY2tzKHBsdWdpbnNQYWNrcykge1xuICBjb25zdCBub3JtYWxpemVkUGx1Z2luc1BhY2tzID0gbWFwT2JqZWN0VmFsdWVzKHBsdWdpbnNQYWNrcywgKHBsdWdpblBhY2ssIHBsdWdpbk5hbWUpID0+IHtcbiAgICBpZiAoIXBsdWdpblBhY2spIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRQbHVnaW5QYWNrID0gbm9ybWFsaXplQ0tDZG5SZXNvdXJjZXNQYWNrKHBsdWdpblBhY2spO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBQcm92aWRlIGRlZmF1bHQgd2luZG93IGFjY2Vzc29yIG9iamVjdCBpZiB0aGUgcGx1Z2luIHBhY2sgZG9lcyBub3QgZGVmaW5lIGl0LlxuICAgICAgY2hlY2tQbHVnaW5Mb2FkZWQ6IGFzeW5jICgpID0+IHdhaXRGb3JXaW5kb3dFbnRyeShbcGx1Z2luTmFtZV0pLFxuICAgICAgLy8gVHJhbnNmb3JtIHRoZSBwbHVnaW4gcGFjayB0byBhIG5vcm1hbGl6ZWQgYWR2YW5jZWQgcGFjay5cbiAgICAgIC4uLm5vcm1hbGl6ZWRQbHVnaW5QYWNrXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBjb21iaW5lQ0tDZG5CdW5kbGVzUGFja3MoXG4gICAgbm9ybWFsaXplZFBsdWdpbnNQYWNrc1xuICApO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGxvYWRDS0VkaXRvckNsb3VkKGNvbmZpZykge1xuICBjb25zdCB7XG4gICAgdmVyc2lvbixcbiAgICB0cmFuc2xhdGlvbnMsXG4gICAgcGx1Z2lucyxcbiAgICBwcmVtaXVtLFxuICAgIGNrYm94LFxuICAgIGNyZWF0ZUN1c3RvbUNkblVybCxcbiAgICBpbmplY3RlZEh0bWxFbGVtZW50c0F0dHJpYnV0ZXMgPSB7XG4gICAgICBjcm9zc29yaWdpbjogXCJhbm9ueW1vdXNcIlxuICAgIH1cbiAgfSA9IGNvbmZpZztcbiAgdmFsaWRhdGVDS0VkaXRvclZlcnNpb24odmVyc2lvbik7XG4gIGNvbnN0IHBhY2sgPSBjb21iaW5lQ0tDZG5CdW5kbGVzUGFja3Moe1xuICAgIENLRWRpdG9yOiBjcmVhdGVDS0NkbkJhc2VCdW5kbGVQYWNrKHtcbiAgICAgIHZlcnNpb24sXG4gICAgICB0cmFuc2xhdGlvbnMsXG4gICAgICBjcmVhdGVDdXN0b21DZG5VcmxcbiAgICB9KSxcbiAgICAuLi5wcmVtaXVtICYmIHtcbiAgICAgIENLRWRpdG9yUHJlbWl1bUZlYXR1cmVzOiBjcmVhdGVDS0NkblByZW1pdW1CdW5kbGVQYWNrKHtcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgdHJhbnNsYXRpb25zLFxuICAgICAgICBjcmVhdGVDdXN0b21DZG5VcmxcbiAgICAgIH0pXG4gICAgfSxcbiAgICAuLi5ja2JveCAmJiB7XG4gICAgICBDS0JveDogY3JlYXRlQ0tCb3hCdW5kbGVQYWNrKGNrYm94KVxuICAgIH0sXG4gICAgbG9hZGVkUGx1Z2luczogY29tYmluZUNkblBsdWdpbnNQYWNrcyhwbHVnaW5zID8/IHt9KVxuICB9KTtcbiAgcmV0dXJuIGxvYWRDS0NkblJlc291cmNlc1BhY2soXG4gICAge1xuICAgICAgLi4ucGFjayxcbiAgICAgIGh0bWxBdHRyaWJ1dGVzOiBpbmplY3RlZEh0bWxFbGVtZW50c0F0dHJpYnV0ZXNcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNLRWRpdG9yVmVyc2lvbih2ZXJzaW9uKSB7XG4gIGlmIChpc0NLQ2RuVGVzdGluZ1ZlcnNpb24odmVyc2lvbikpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIllvdSBhcmUgdXNpbmcgYSB0ZXN0aW5nIHZlcnNpb24gb2YgQ0tFZGl0b3IgNS4gUGxlYXNlIHJlbWVtYmVyIHRoYXQgaXQgaXMgbm90IHN1aXRhYmxlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cy5cIlxuICAgICk7XG4gIH1cbiAgaWYgKCFpc0NLQ2RuU3VwcG9ydGVkQnlFZGl0b3JWZXJzaW9uKHZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSBDS0VkaXRvciA1IENETiBjYW4ndCBiZSB1c2VkIHdpdGggdGhlIGdpdmVuIGVkaXRvciB2ZXJzaW9uOiAke3ZlcnNpb259LiBQbGVhc2UgbWFrZSBzdXJlIHlvdSBhcmUgdXNpbmcgYXQgbGVhc3QgdGhlIENLRWRpdG9yIDUgdmVyc2lvbiA0NC5gXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgeyBDS0JPWF9DRE5fVVJMLCBDS19DRE5fVVJMLCBJTkpFQ1RFRF9TQ1JJUFRTLCBJTkpFQ1RFRF9TVFlMRVNIRUVUUywgYXBwZW5kRXh0cmFQbHVnaW5zVG9FZGl0b3JDb25maWcsIGNyZWF0ZUNLQm94Q2RuVXJsLCBjcmVhdGVDS0NkblVybCwgY3JlYXRlRGVmZXIsIGNyZWF0ZUludGVncmF0aW9uVXNhZ2VEYXRhUGx1Z2luLCBmaWx0ZXJCbGFua09iamVjdFZhbHVlcywgZmlsdGVyT2JqZWN0VmFsdWVzLCBpbmplY3RTY3JpcHQsIGluamVjdFNjcmlwdHNJblBhcmFsbGVsLCBpbmplY3RTdHlsZXNoZWV0LCBpc0NLRWRpdG9yRnJlZUxpY2Vuc2UsIGlzU1NSLCBsb2FkQ0tFZGl0b3JDbG91ZCwgbWFwT2JqZWN0VmFsdWVzLCBvbmNlLCBvdmVyd3JpdGVBcnJheSwgb3ZlcndyaXRlT2JqZWN0LCBwcmVsb2FkUmVzb3VyY2UsIHNoYWxsb3dDb21wYXJlQXJyYXlzLCB1aWQsIHVuaXEsIHdhaXRGb3IsIHdhaXRGb3JXaW5kb3dFbnRyeSwgd2l0aG91dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@ckeditor/ckeditor5-integrations-common/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@ckeditor/ckeditor5-react/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ckeditor/ckeditor5-react/dist/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CKEditor: function() { return /* binding */ CKEditor; },\n/* harmony export */   CKEditorContext: function() { return /* binding */ CKEditorContext; },\n/* harmony export */   loadCKEditorCloud: function() { return /* reexport safe */ _ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.loadCKEditorCloud; },\n/* harmony export */   useCKEditorCloud: function() { return /* binding */ useCKEditorCloud; },\n/* harmony export */   useMultiRootEditor: function() { return /* binding */ useMultiRootEditor; },\n/* harmony export */   withCKEditorCloud: function() { return /* binding */ withCKEditorCloud; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ckeditor/ckeditor5-integrations-common */ \"(app-pages-browser)/./node_modules/@ckeditor/ckeditor5-integrations-common/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n\n\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst _LifeCycleElementSemaphore = class _LifeCycleElementSemaphore {\n  constructor(element, lifecycle) {\n    /**\n     * This should define async methods for initializing and destroying the editor.\n     * Essentially, it's an async version of basic React lifecycle methods like `componentDidMount`, `componentWillUnmount`.\n     *\n     * \t* Result of {@link LifeCycleAsyncOperators#mount} method is passed to {@link LifeCycleAsyncOperators#unmount} as an argument.\n     */\n    __publicField(this, \"_lifecycle\");\n    /**\n     * This is the element instance that the editor uses for mounting. This element should contain the `ckeditorInstance` member\n     * once the editor has been successfully mounted to it. The semaphore ensures that a new instance of the editor, which will\n     * be assigned to this element by the {@link #_lifecycle:mount} method, will always be initialized after the successful\n     * destruction of the underlying `ckeditorInstance` that was previously mounted on this element.\n     */\n    __publicField(this, \"_element\");\n    /**\n     * This is the lock mechanism utilized by the {@link #lock} and {@link #release} methods.\n     *\n     * \t* If the editor is not yet mounted and is awaiting mounting (for instance, when another editor is\n     * \t  occupying the element), then it is null.\n     *\n     * \t* When the editor is mounted on the element, this variable holds an unresolved promise that will be\n     * \t  resolved after the editor is destroyed.\n     *\n     * \t* Once the editor is destroyed (and it was previously mounted), the promise is resolved.\n     */\n    __publicField(this, \"_releaseLock\", null);\n    /**\n     * This is the result of the {@link #_lifecycle:mount} function. This value should be reset to `null`\n     * once the semaphore is released. It is utilized to store certain data that must be removed following\n     * the destruction of the editor. This data may include the editor's instance, the assigned watchdog,\n     * or handles for additional window listeners.\n     */\n    __publicField(this, \"_value\", null);\n    /**\n     * This is a list of callbacks that are triggered if the semaphore {@link #_lifecycle:mount} method executes successfully.\n     * It is utilized in scenarios where we need to assign certain properties to an editor that is currently in the process of mounting.\n     * An instance of such usage could be two-way binding. We aim to prevent the loss of all `setData` calls if the editor has not\n     * yet been mounted, therefore these calls will be executed immediately following the completion of the mounting process.\n     */\n    __publicField(this, \"_afterMountCallbacks\", []);\n    /**\n     * This represents the actual mounting state of the semaphore. It is primarily used by the {@link #release} method to\n     * determine whether the initialization of the editor should be skipped or, if the editor is already initialized, the editor\n     * should be destroyed.\n     *\n     * \t* If `destroyedBeforeInitialization` is true, then the {@link #release} method was invoked before the editor began to mount.\n     * \t  This often occurs in strict mode when we assign a promise to the {@link LifeCycleEditorElementSemaphore#_semaphores} map\n     * \t  and the assigned `mount` callback has not yet been called. In this scenario, it is safe to skip the initialization of the editor\n     * \t  and simply release the semaphore.\n     *\n     *\t* If `mountingInProgress` is a Promise, then the {@link #release} method was invoked after the initialization of the editor and\n     \t  the editor must be destroyed before the semaphore is released.\n    */\n    __publicField(this, \"_state\", {\n      destroyedBeforeInitialization: false,\n      mountingInProgress: null\n    });\n    /**\n     * Inverse of {@link #_lock} method that tries to destroy attached editor.\n     *\n     * \t* If editor is being already attached to element (or is in attaching process) then after fully initialization of editor\n     * \t  destroy is performed and semaphore is released. The {@link #_lifecycle} unmount method is called.\n     *\n     * \t* If editor is being destroyed before initialization then it does nothing but sets `destroyedBeforeInitialization` flag that\n     * \t  will be later checked by {@link #_lock} method in initialization. The {@link #_lifecycle} unmount method is not called.\n     *\n     * *Important note:*\n     *\n     * Its really important to keep this method *sync*. If we make this method *async*, it wont work well because\n     * it will cause problems when were trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.\n     */\n    __publicField(this, \"release\", (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.once)(() => {\n      const { _releaseLock, _state, _element, _lifecycle } = this;\n      if (_state.mountingInProgress) {\n        _state.mountingInProgress.then(() => _lifecycle.unmount({\n          element: _element,\n          // Mount result might be overridden by watchdog during restart so use instance variable.\n          mountResult: this.value\n        })).catch((error) => {\n          console.error(\"CKEditor unmounting error:\", error);\n        }).then(_releaseLock.resolve).then(() => {\n          this._value = null;\n        });\n      } else {\n        _state.destroyedBeforeInitialization = true;\n        _releaseLock.resolve();\n      }\n    }));\n    this._element = element;\n    this._lifecycle = lifecycle;\n    this._lock();\n  }\n  /**\n   * Getter for {@link #_value}.\n   */\n  get value() {\n    return this._value;\n  }\n  /**\n   * Resets the semaphore to its initial state.\n   */\n  discard() {\n    this._value = null;\n    this._releaseLock = null;\n    this._afterMountCallbacks = [];\n    this._state = {\n      destroyedBeforeInitialization: false,\n      mountingInProgress: null\n    };\n  }\n  /**\n   * Occasionally, the Watchdog restarts the editor instance, resulting in a new instance being assigned to the semaphore.\n   * In terms of race conditions, it's generally safer to simply override the semaphore value rather than recreating it\n   * with a different one.\n   */\n  unsafeSetValue(value) {\n    this._value = value;\n    this._afterMountCallbacks.forEach((callback) => {\n      if (this._lifecycle.isValueValid && !this._lifecycle.isValueValid(value)) {\n        return;\n      }\n      callback(value);\n    });\n    this._afterMountCallbacks = [];\n  }\n  /**\n   * This registers a callback that will be triggered after the editor has been successfully mounted.\n   *\n   * \t* If the editor is already mounted, the callback will be executed immediately.\n   *\t* If the editor is in the process of mounting, the callback will be executed upon successful mounting.\n  * \t* If the editor is never mounted, the passed callback will not be executed.\n  * \t* If an exception is thrown within the callback, it will be re-thrown in the semaphore.\n  * \t* If the value is not valid (determined by isValueValid), the callback will not be executed.\n  */\n  runAfterMount(callback) {\n    const { _value, _afterMountCallbacks } = this;\n    if (_value) {\n      if (this._lifecycle.isValueValid && !this._lifecycle.isValueValid(_value)) {\n        return;\n      }\n      callback(_value);\n    } else {\n      _afterMountCallbacks.push(callback);\n    }\n  }\n  /**\n   * This method is used to inform other components that the {@link #_element} will be used by the editor,\n   * which is initialized by the {@link #_lifecycle} methods.\n   *\n   * \t* If an editor is already present on the provided element, the initialization of the current one\n   * \t  will be postponed until the previous one is destroyed.\n   *\n   * \t* If the element is empty and does not have an editor attached to it, the currently locked editor will\n   * \t  be mounted immediately.\n   *\n   * After the successful initialization of the editor and the assignment of the {@link #_value} member,\n   * the `onReady` lifecycle method is called.\n   *\n   * *Important note:*\n   *\n   * Its really important to keep this method *sync*. If we make this method *async*, it wont work well because\n   * it will cause problems when were trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.\n   */\n  _lock() {\n    const { _semaphores } = _LifeCycleElementSemaphore;\n    const { _state, _element, _lifecycle } = this;\n    const prevElementSemaphore = _semaphores.get(_element) || Promise.resolve(null);\n    const releaseLock = (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.createDefer)();\n    this._releaseLock = releaseLock;\n    const newElementSemaphore = prevElementSemaphore.then(() => {\n      if (_state.destroyedBeforeInitialization) {\n        return Promise.resolve(void 0);\n      }\n      _state.mountingInProgress = _lifecycle.mount().then((mountResult) => {\n        if (mountResult) {\n          this.unsafeSetValue(mountResult);\n        }\n        return mountResult;\n      });\n      return _state.mountingInProgress;\n    }).then(async (mountResult) => {\n      if (mountResult && _lifecycle.afterMount) {\n        await _lifecycle.afterMount({\n          element: _element,\n          mountResult\n        });\n      }\n    }).then(() => releaseLock.promise).catch((error) => {\n      console.error(\"CKEditor mounting error:\", error);\n    }).then(() => {\n      if (_semaphores.get(_element) === newElementSemaphore) {\n        _semaphores.delete(_element);\n      }\n    });\n    _semaphores.set(_element, newElementSemaphore);\n  }\n};\n/**\n * This is a map of elements associated with promises. It informs the semaphore that the underlying HTML element, used as a key,\n * is currently in use by another editor. Each element is assigned a promise, which allows for the easy chaining of new\n * editor instances on an element that is already in use by another instance. The process works as follows:\n *\n * \t1. If an element is being used by an editor, then the initialization of a new editor\n * \t   instance is chained using the `.then()` method of the Promise.\n *\n * \t2. If the editor associated with the underlying element is destroyed, then `Promise.resolve()` is called\n * \t   and the previously assigned `.then()` editor callback is executed.\n *\n *  @see {@link #lock} for more detailed information on the implementation.\n */\n__publicField(_LifeCycleElementSemaphore, \"_semaphores\", /* @__PURE__ */ new Map());\nlet LifeCycleElementSemaphore = _LifeCycleElementSemaphore;\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst ReactContextMetadataKey = \"$__CKEditorReactContextMetadata\";\nfunction withCKEditorReactContextMetadata(metadata, config) {\n  return {\n    ...config,\n    [ReactContextMetadataKey]: metadata\n  };\n}\nfunction tryExtractCKEditorReactContextMetadata(object) {\n  return object.get(ReactContextMetadataKey);\n}\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useIsMountedRef = () => {\n  const mountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    mountedRef.current = true;\n    return () => {\n      mountedRef.current = false;\n    };\n  }, []);\n  return mountedRef;\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useRefSafeCallback = (fn) => {\n  const callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  callbackRef.current = fn;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (...args) => callbackRef.current(...args),\n    []\n  );\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useInitializedCKEditorsMap = ({\n  currentContextWatchdog,\n  onChangeInitializedEditors\n}) => {\n  const onChangeInitializedEditorsSafe = useRefSafeCallback(onChangeInitializedEditors || (() => {\n  }));\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var _a;\n    if (currentContextWatchdog.status !== \"initialized\") {\n      return;\n    }\n    const { watchdog } = currentContextWatchdog;\n    const editors = (_a = watchdog == null ? void 0 : watchdog.context) == null ? void 0 : _a.editors;\n    if (!editors) {\n      return;\n    }\n    const getInitializedContextEditors = () => [...editors].reduce(\n      (map, editor) => {\n        var _a2;\n        if (editor.state !== \"ready\") {\n          return map;\n        }\n        const metadata = tryExtractCKEditorReactContextMetadata(editor.config);\n        const nameOrId = (_a2 = metadata == null ? void 0 : metadata.name) != null ? _a2 : editor.id;\n        map[nameOrId] = {\n          instance: editor,\n          metadata\n        };\n        return map;\n      },\n      /* @__PURE__ */ Object.create({})\n      // Prevent the prototype pollution.\n    );\n    const onEditorStatusChange = () => {\n      onChangeInitializedEditorsSafe(\n        getInitializedContextEditors(),\n        watchdog\n      );\n    };\n    const trackEditorLifecycle = (editor) => {\n      editor.once(\"ready\", onEditorStatusChange, { priority: \"lowest\" });\n      editor.once(\"destroy\", onEditorStatusChange, { priority: \"lowest\" });\n    };\n    const onAddEditorToCollection = (_, editor) => {\n      trackEditorLifecycle(editor);\n    };\n    editors.forEach(trackEditorLifecycle);\n    editors.on(\"add\", onAddEditorToCollection);\n    if (Array.from(editors).some((editor) => editor.state === \"ready\")) {\n      onEditorStatusChange();\n    }\n    return () => {\n      editors.off(\"add\", onAddEditorToCollection);\n    };\n  }, [currentContextWatchdog]);\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst ContextWatchdogContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst CKEditorContext = (props) => {\n  const {\n    id,\n    context,\n    watchdogConfig,\n    children,\n    config,\n    onReady,\n    contextWatchdog: ContextWatchdogConstructor,\n    isLayoutReady = true,\n    onChangeInitializedEditors,\n    onError = (error, details) => console.error(error, details)\n  } = props;\n  const isMountedRef = useIsMountedRef();\n  const prevWatchdogInitializationIDRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const [currentContextWatchdog, setCurrentContextWatchdog] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n    status: \"initializing\"\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (isLayoutReady) {\n      initializeContextWatchdog();\n    } else {\n      setCurrentContextWatchdog({\n        status: \"initializing\"\n      });\n    }\n  }, [id, isLayoutReady]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => () => {\n    if (currentContextWatchdog.status === \"initialized\") {\n      currentContextWatchdog.watchdog.destroy();\n    }\n  }, [currentContextWatchdog]);\n  useInitializedCKEditorsMap({\n    currentContextWatchdog,\n    onChangeInitializedEditors\n  });\n  function regenerateInitializationID() {\n    prevWatchdogInitializationIDRef.current = (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.uid)();\n    return prevWatchdogInitializationIDRef.current;\n  }\n  function canUpdateState(initializationID) {\n    return prevWatchdogInitializationIDRef.current === initializationID && isMountedRef.current;\n  }\n  function initializeContextWatchdog() {\n    const watchdogInitializationID = regenerateInitializationID();\n    const contextWatchdog = new ContextWatchdogConstructor(context, watchdogConfig);\n    contextWatchdog.on(\"error\", (_, errorEvent) => {\n      /* istanbul ignore else -- @preserve */\n      if (canUpdateState(watchdogInitializationID)) {\n        onError(errorEvent.error, {\n          phase: \"runtime\",\n          willContextRestart: errorEvent.causesRestart\n        });\n      }\n    });\n    contextWatchdog.on(\"stateChange\", () => {\n      if (onReady && contextWatchdog.state === \"ready\" && canUpdateState(watchdogInitializationID)) {\n        onReady(\n          contextWatchdog.context,\n          contextWatchdog\n        );\n      }\n    });\n    contextWatchdog.create(config).then(() => {\n      if (canUpdateState(watchdogInitializationID)) {\n        setCurrentContextWatchdog({\n          status: \"initialized\",\n          watchdog: contextWatchdog\n        });\n      } else {\n        contextWatchdog.destroy();\n      }\n    }).catch((error) => {\n      if (canUpdateState(watchdogInitializationID)) {\n        onError(error, {\n          phase: \"initialization\",\n          willContextRestart: false\n        });\n        setCurrentContextWatchdog({\n          status: \"error\",\n          error\n        });\n      }\n    });\n    return contextWatchdog;\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextWatchdogContext.Provider, { value: currentContextWatchdog }, children);\n};\nconst isContextWatchdogValue = (obj) => !!obj && typeof obj === \"object\" && \"status\" in obj && [\"initializing\", \"initialized\", \"error\"].includes(obj.status);\nconst isContextWatchdogValueWithStatus = (status) => (obj) => isContextWatchdogValue(obj) && obj.status === status;\nconst isContextWatchdogInitializing = isContextWatchdogValueWithStatus(\"initializing\");\nconst isContextWatchdogReadyToUse = (obj) => isContextWatchdogValueWithStatus(\"initialized\")(obj) && obj.watchdog.state === \"ready\";\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst ReactIntegrationUsageDataPlugin = (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.createIntegrationUsageDataPlugin)(\n  \"react\",\n  {\n    version: \"11.0.0\",\n    frameworkVersion: react__WEBPACK_IMPORTED_MODULE_0__.version\n  }\n);\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction appendAllIntegrationPluginsToConfig(editorConfig) {\n  if ((0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.isCKEditorFreeLicense)(editorConfig.licenseKey)) {\n    return editorConfig;\n  }\n  return (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.appendExtraPluginsToEditorConfig)(editorConfig, [\n    /**\n     * This part of the code is not executed in open-source implementations using a GPL key.\n     * It only runs when a specific license key is provided. If you are uncertain whether\n     * this applies to your installation, please contact our support team.\n     */\n    ReactIntegrationUsageDataPlugin\n  ]);\n}\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID$1 = \"Lock from React integration (@ckeditor/ckeditor5-react)\";\nclass CKEditor extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    super(props);\n    /**\n     * After mounting the editor, the variable will contain a reference to the created editor.\n     * @see: https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html\n     */\n    __publicField(this, \"domContainer\", react__WEBPACK_IMPORTED_MODULE_0__.createRef());\n    /**\n     * Unlocks element in editor semaphore after destroy editor instance.\n     */\n    __publicField(this, \"editorSemaphore\", null);\n    this._checkVersion();\n  }\n  /**\n   * Checks if the CKEditor version used in the application is compatible with the component.\n   */\n  _checkVersion() {\n    const { CKEDITOR_VERSION } = window;\n    if (!CKEDITOR_VERSION) {\n      return console.warn('Cannot find the \"CKEDITOR_VERSION\" in the \"window\" scope.');\n    }\n    const [major] = CKEDITOR_VERSION.split(\".\").map(Number);\n    if (major >= 42 || CKEDITOR_VERSION.startsWith(\"0.0.0\")) {\n      return;\n    }\n    console.warn(\"The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.\");\n  }\n  get _semaphoreValue() {\n    const { editorSemaphore } = this;\n    return editorSemaphore ? editorSemaphore.value : null;\n  }\n  /**\n   * An watchdog instance.\n   */\n  get watchdog() {\n    const { _semaphoreValue } = this;\n    return _semaphoreValue ? _semaphoreValue.watchdog : null;\n  }\n  /**\n   * An editor instance.\n   */\n  get editor() {\n    const { _semaphoreValue } = this;\n    return _semaphoreValue ? _semaphoreValue.instance : null;\n  }\n  /**\n   * The CKEditor component should not be updated by React itself.\n   * However, if the component identifier changes, the whole structure should be created once again.\n   */\n  shouldComponentUpdate(nextProps) {\n    const { props, editorSemaphore } = this;\n    if (nextProps.id !== props.id) {\n      return true;\n    }\n    if (nextProps.disableWatchdog !== props.disableWatchdog) {\n      return true;\n    }\n    if (editorSemaphore) {\n      editorSemaphore.runAfterMount(({ instance }) => {\n        if (this._shouldUpdateEditorData(props, nextProps, instance)) {\n          instance.data.set(nextProps.data);\n        }\n      });\n      if (\"disabled\" in nextProps) {\n        editorSemaphore.runAfterMount(({ instance }) => {\n          if (nextProps.disabled) {\n            instance.enableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID$1);\n          } else {\n            instance.disableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID$1);\n          }\n        });\n      }\n    }\n    return false;\n  }\n  /**\n   * Initialize the editor when the component is mounted.\n   */\n  componentDidMount() {\n    if (!isContextWatchdogInitializing(this.context)) {\n      this._initLifeCycleSemaphore();\n    }\n  }\n  /**\n   * Re-render the entire component once again. The old editor will be destroyed and the new one will be created.\n   */\n  componentDidUpdate() {\n    if (!isContextWatchdogInitializing(this.context)) {\n      this._initLifeCycleSemaphore();\n    }\n  }\n  /**\n   * Destroy the editor before unmounting the component.\n   */\n  componentWillUnmount() {\n    this._unlockLifeCycleSemaphore();\n  }\n  /**\n   * Async destroy attached editor and unlock element semaphore.\n   */\n  _unlockLifeCycleSemaphore() {\n    if (this.editorSemaphore) {\n      this.editorSemaphore.release();\n      this.editorSemaphore = null;\n    }\n  }\n  /**\n   * Unlocks previous editor semaphore and creates new one..\n   */\n  _initLifeCycleSemaphore() {\n    this._unlockLifeCycleSemaphore();\n    this.editorSemaphore = new LifeCycleElementSemaphore(this.domContainer.current, {\n      isValueValid: (value) => value && !!value.instance,\n      mount: async () => {\n        var _a, _b;\n        try {\n          return await this._initializeEditor();\n        } catch (error) {\n          (_b = (_a = this.props).onError) == null ? void 0 : _b.call(_a, error, { phase: \"initialization\", willEditorRestart: false });\n          throw error;\n        }\n      },\n      afterMount: ({ mountResult }) => {\n        const { onReady } = this.props;\n        if (onReady && this.domContainer.current !== null) {\n          onReady(mountResult.instance);\n        }\n      },\n      unmount: async ({ element, mountResult }) => {\n        const { onAfterDestroy } = this.props;\n        try {\n          await this._destroyEditor(mountResult);\n          element.innerHTML = \"\";\n        } finally {\n          if (onAfterDestroy) {\n            onAfterDestroy(mountResult.instance);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Render a <div> element which will be replaced by CKEditor.\n   */\n  render() {\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: this.domContainer });\n  }\n  /**\n   * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.\n   */\n  async _initializeEditor() {\n    if (this.props.disableWatchdog) {\n      const instance = await this._createEditor(this.domContainer.current, this._getConfig());\n      return {\n        instance,\n        watchdog: null\n      };\n    }\n    const watchdog = (() => {\n      if (isContextWatchdogReadyToUse(this.context)) {\n        return new EditorWatchdogAdapter(this.context.watchdog);\n      }\n      return new this.props.editor.EditorWatchdog(this.props.editor, this.props.watchdogConfig);\n    })();\n    const totalRestartsRef = {\n      current: 0\n    };\n    watchdog.setCreator(async (el, config) => {\n      var _a;\n      const { editorSemaphore } = this;\n      const { onAfterDestroy } = this.props;\n      if (totalRestartsRef.current > 0 && onAfterDestroy && ((_a = editorSemaphore == null ? void 0 : editorSemaphore.value) == null ? void 0 : _a.instance)) {\n        onAfterDestroy(editorSemaphore.value.instance);\n      }\n      const instance = await this._createEditor(el, config);\n      if (editorSemaphore && totalRestartsRef.current > 0) {\n        editorSemaphore.unsafeSetValue({\n          instance,\n          watchdog\n        });\n        setTimeout(() => {\n          if (this.props.onReady) {\n            this.props.onReady(watchdog.editor);\n          }\n        });\n      }\n      totalRestartsRef.current++;\n      return instance;\n    });\n    watchdog.on(\"error\", (_, { error, causesRestart }) => {\n      const onError = this.props.onError || console.error;\n      onError(error, { phase: \"runtime\", willEditorRestart: causesRestart });\n    });\n    await watchdog.create(this.domContainer.current, this._getConfig());\n    return {\n      watchdog,\n      instance: watchdog.editor\n    };\n  }\n  /**\n   * Creates an editor from the element and configuration.\n   *\n   * @param element The source element.\n   * @param config CKEditor 5 editor configuration.\n   */\n  _createEditor(element, config) {\n    const { contextItemMetadata } = this.props;\n    if (contextItemMetadata) {\n      config = withCKEditorReactContextMetadata(contextItemMetadata, config);\n    }\n    return this.props.editor.create(\n      element,\n      appendAllIntegrationPluginsToConfig(config)\n    ).then((editor) => {\n      if (\"disabled\" in this.props) {\n        /* istanbul ignore else -- @preserve */\n        if (this.props.disabled) {\n          editor.enableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID$1);\n        }\n      }\n      const modelDocument = editor.model.document;\n      const viewDocument = editor.editing.view.document;\n      modelDocument.on(\"change:data\", (event) => {\n        /* istanbul ignore else -- @preserve */\n        if (this.props.onChange) {\n          this.props.onChange(event, editor);\n        }\n      });\n      viewDocument.on(\"focus\", (event) => {\n        /* istanbul ignore else -- @preserve */\n        if (this.props.onFocus) {\n          this.props.onFocus(event, editor);\n        }\n      });\n      viewDocument.on(\"blur\", (event) => {\n        /* istanbul ignore else -- @preserve */\n        if (this.props.onBlur) {\n          this.props.onBlur(event, editor);\n        }\n      });\n      return editor;\n    });\n  }\n  /**\n   * Destroys the editor by destroying the watchdog.\n   */\n  async _destroyEditor(initializeResult) {\n    const { watchdog, instance } = initializeResult;\n    return new Promise((resolve, reject) => {\n      /* istanbul ignore next -- @preserve */\n      setTimeout(async () => {\n        try {\n          if (watchdog) {\n            await watchdog.destroy();\n            return resolve();\n          }\n          if (instance) {\n            await instance.destroy();\n            return resolve();\n          }\n          resolve();\n        } catch (e) {\n          console.error(e);\n          reject(e);\n        }\n      });\n    });\n  }\n  /**\n   * Returns true when the editor should be updated.\n   *\n   * @param prevProps Previous react's properties.\n   * @param nextProps React's properties.\n   * @param editor Current editor instance.\n   */\n  _shouldUpdateEditorData(prevProps, nextProps, editor) {\n    if (prevProps.data === nextProps.data) {\n      return false;\n    }\n    if (editor.data.get() === nextProps.data) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Returns the editor configuration.\n   */\n  _getConfig() {\n    const config = this.props.config || {};\n    if (this.props.data && config.initialData) {\n      console.warn(\n        \"Editor data should be provided either using `config.initialData` or `content` property. The config value takes precedence over `content` property and will be used when both are specified.\"\n      );\n    }\n    return {\n      ...config,\n      initialData: config.initialData || this.props.data || \"\"\n    };\n  }\n}\n__publicField(CKEditor, \"contextType\", ContextWatchdogContext);\nclass EditorWatchdogAdapter {\n  /**\n   * @param contextWatchdog The context watchdog instance that will be wrapped into editor watchdog API.\n   */\n  constructor(contextWatchdog) {\n    /**\n     * The context watchdog instance that will be wrapped into editor watchdog API.\n     */\n    __publicField(this, \"_contextWatchdog\");\n    /**\n     * A unique id for the adapter to distinguish editor items when using the context watchdog API.\n     */\n    __publicField(this, \"_id\");\n    /**\n     * A watchdog's editor creator function.\n     */\n    __publicField(this, \"_creator\");\n    this._contextWatchdog = contextWatchdog;\n    this._id = (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.uid)();\n  }\n  /**\n   *  @param creator A watchdog's editor creator function.\n   */\n  setCreator(creator) {\n    this._creator = creator;\n  }\n  /**\n   * Adds an editor configuration to the context watchdog registry. Creates an instance of it.\n   *\n   * @param sourceElementOrData A source element or data for the new editor.\n   * @param config CKEditor 5 editor config.\n   */\n  create(sourceElementOrData, config) {\n    return this._contextWatchdog.add({\n      sourceElementOrData,\n      config,\n      creator: this._creator,\n      id: this._id,\n      type: \"editor\"\n    });\n  }\n  /**\n   * Creates a listener that is attached to context watchdog's item and run when the context watchdog fires.\n   * Currently works only for the `error` event.\n   */\n  on(_, callback) {\n    this._contextWatchdog.on(\"itemError\", (_2, { itemId, error }) => {\n      if (itemId === this._id) {\n        callback(null, { error, causesRestart: void 0 });\n      }\n    });\n  }\n  destroy() {\n    if (this._contextWatchdog.state === \"ready\") {\n      return this._contextWatchdog.remove(this._id);\n    }\n    return Promise.resolve();\n  }\n  /**\n   * An editor instance.\n   */\n  get editor() {\n    return this._contextWatchdog.getItem(this._id);\n  }\n}\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useLifeCycleSemaphoreSyncRef = () => {\n  const semaphoreRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const [revision, setRevision] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => Date.now());\n  const refresh = () => {\n    setRevision(Date.now());\n  };\n  const release = (rerender = true) => {\n    if (semaphoreRef.current) {\n      semaphoreRef.current.release();\n      semaphoreRef.current = null;\n    }\n    if (rerender) {\n      setRevision(Date.now());\n    }\n  };\n  const unsafeSetValue = (value) => {\n    var _a;\n    (_a = semaphoreRef.current) == null ? void 0 : _a.unsafeSetValue(value);\n    refresh();\n  };\n  const runAfterMount = (callback) => {\n    if (semaphoreRef.current) {\n      semaphoreRef.current.runAfterMount(callback);\n    }\n  };\n  const replace = (newSemaphore) => {\n    release(false);\n    semaphoreRef.current = newSemaphore();\n    refresh();\n    runAfterMount(refresh);\n  };\n  const createAttributeRef = (key) => ({\n    get current() {\n      if (!semaphoreRef.current || !semaphoreRef.current.value) {\n        return null;\n      }\n      return semaphoreRef.current.value[key];\n    }\n  });\n  return {\n    get current() {\n      return semaphoreRef.current;\n    },\n    revision,\n    createAttributeRef,\n    unsafeSetValue,\n    release,\n    replace,\n    runAfterMount\n  };\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction mergeRefs(...refs) {\n  return (value) => {\n    refs.forEach((ref) => {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useInstantEffect = (fn, deps) => {\n  const [prevDeps, setDeps] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  if (!(0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.shallowCompareArrays)(prevDeps, deps)) {\n    fn();\n    setDeps([...deps]);\n  }\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useInstantEditorEffect = (semaphore, fn, deps) => {\n  useInstantEffect(() => {\n    if (semaphore) {\n      semaphore.runAfterMount(fn);\n    }\n  }, [semaphore, ...deps]);\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID = \"Lock from React integration (@ckeditor/ckeditor5-react)\";\nconst useMultiRootEditor = (props) => {\n  const semaphoreElementRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(props.semaphoreElement || null);\n  const semaphore = useLifeCycleSemaphoreSyncRef();\n  const editorRefs = {\n    watchdog: semaphore.createAttributeRef(\"watchdog\"),\n    instance: semaphore.createAttributeRef(\"instance\")\n  };\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ContextWatchdogContext);\n  const [roots, setRoots] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => Object.keys(props.data));\n  const [data, setData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({ ...props.data });\n  const [attributes, setAttributes] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({ ...props.rootsAttributes });\n  const shouldUpdateEditor = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n  const forceAssignFakeEditableElements = () => {\n    const editor = editorRefs.instance.current;\n    if (!editor) {\n      return;\n    }\n    const initializeEditableWithFakeElement = (editable) => {\n      if (editable.name && !editor.editing.view.getDomRoot(editable.name)) {\n        editor.editing.view.attachDomRoot(document.createElement(\"div\"), editable.name);\n      }\n    };\n    Object.values(editor.ui.view.editables).forEach(initializeEditableWithFakeElement);\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const semaphoreElement = semaphoreElementRef.current;\n    if (context && !isContextWatchdogReadyToUse(context)) {\n      return;\n    }\n    if (!semaphoreElement || props.isLayoutReady === false) {\n      return;\n    }\n    semaphore.replace(() => new LifeCycleElementSemaphore(semaphoreElement, {\n      mount: _initializeEditor,\n      afterMount: ({ mountResult }) => {\n        const { onReady } = props;\n        if (onReady && semaphoreElementRef.current !== null) {\n          onReady(mountResult.instance);\n        }\n      },\n      unmount: async ({ element, mountResult }) => {\n        const { onAfterDestroy } = props;\n        try {\n          await _destroyEditor(mountResult);\n          element.innerHTML = \"\";\n        } finally {\n          if (onAfterDestroy) {\n            onAfterDestroy(mountResult.instance);\n          }\n        }\n      }\n    }));\n    return () => {\n      forceAssignFakeEditableElements();\n      semaphore.release(false);\n    };\n  }, [props.id, props.isLayoutReady, context == null ? void 0 : context.status]);\n  const _getConfig = () => {\n    const config = props.config || {};\n    if (props.data && config.initialData) {\n      console.warn(\n        \"Editor data should be provided either using `config.initialData` or `data` property. The config value takes precedence over `data` property and will be used when both are specified.\"\n      );\n    }\n    return {\n      ...config,\n      rootsAttributes: attributes\n    };\n  };\n  const onChangeData = useRefSafeCallback((editor, event) => {\n    const modelDocument = editor.model.document;\n    if (!props.disableTwoWayDataBinding) {\n      const newData = {};\n      const newAttributes = {};\n      modelDocument.differ.getChanges().forEach((change) => {\n        let root;\n        /* istanbul ignore else -- @preserve */\n        if (change.type == \"insert\" || change.type == \"remove\") {\n          root = change.position.root;\n        } else {\n          root = change.range.root;\n        }\n        if (!root.isAttached()) {\n          return;\n        }\n        const { rootName } = root;\n        newData[rootName] = editor.getData({ rootName });\n      });\n      modelDocument.differ.getChangedRoots().forEach((changedRoot) => {\n        if (changedRoot.state) {\n          if (newData[changedRoot.name] !== void 0) {\n            delete newData[changedRoot.name];\n          }\n          return;\n        }\n        const rootName = changedRoot.name;\n        newAttributes[rootName] = editor.getRootAttributes(rootName);\n      });\n      if (Object.keys(newData).length) {\n        setData((previousData) => ({ ...previousData, ...newData }));\n      }\n      if (Object.keys(newAttributes).length) {\n        setAttributes((previousAttributes) => ({ ...previousAttributes, ...newAttributes }));\n      }\n    }\n    /* istanbul ignore else -- @preserve */\n    if (props.onChange) {\n      props.onChange(event, editor);\n    }\n  });\n  const onAddRoot = useRefSafeCallback((editor, _evt, root) => {\n    const rootName = root.rootName;\n    if (!props.disableTwoWayDataBinding) {\n      setData(\n        (previousData) => ({ ...previousData, [rootName]: editor.getData({ rootName }) })\n      );\n      setAttributes(\n        (previousAttributes) => ({ ...previousAttributes, [rootName]: editor.getRootAttributes(rootName) })\n      );\n    }\n    setRoots((prevRoots) => (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.uniq)([...prevRoots, root.rootName]));\n  });\n  const onDetachRoot = useRefSafeCallback((_editor, _evt, root) => {\n    const rootName = root.rootName;\n    if (!props.disableTwoWayDataBinding) {\n      setData((previousData) => {\n        const { [rootName]: _, ...newData } = previousData;\n        return { ...newData };\n      });\n      setAttributes((previousAttributes) => {\n        const { [rootName]: _, ...newAttributes } = previousAttributes;\n        return { ...newAttributes };\n      });\n    }\n    setRoots((prevRoots) => prevRoots.filter((root2) => root2 !== rootName));\n  });\n  const _createEditor = useRefSafeCallback((initialData, config) => {\n    (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.overwriteObject)({ ...props.rootsAttributes }, attributes);\n    (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.overwriteObject)({ ...props.data }, data);\n    (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.overwriteArray)(Object.keys(props.data), roots);\n    return props.editor.create(\n      initialData,\n      appendAllIntegrationPluginsToConfig(config)\n    ).then((editor) => {\n      const editorData = editor.getFullData();\n      (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.overwriteObject)({ ...editorData }, data);\n      (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.overwriteObject)({ ...editor.getRootsAttributes() }, attributes);\n      (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.overwriteArray)(Object.keys(editorData), roots);\n      if (props.disabled) {\n        /* istanbul ignore else -- @preserve */\n        editor.enableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID);\n      }\n      const modelDocument = editor.model.document;\n      const viewDocument = editor.editing.view.document;\n      modelDocument.on(\"change:data\", (evt) => onChangeData(editor, evt));\n      editor.on(\"addRoot\", (evt, root) => onAddRoot(editor, evt, root));\n      editor.on(\"detachRoot\", (evt, root) => onDetachRoot(editor, evt, root));\n      viewDocument.on(\"focus\", (event) => {\n        /* istanbul ignore else -- @preserve */\n        if (props.onFocus) {\n          props.onFocus(event, editor);\n        }\n      });\n      viewDocument.on(\"blur\", (event) => {\n        /* istanbul ignore else -- @preserve */\n        if (props.onBlur) {\n          props.onBlur(event, editor);\n        }\n      });\n      return editor;\n    });\n  });\n  const _destroyEditor = (initializeResult) => {\n    const { watchdog, instance } = initializeResult;\n    return new Promise((resolve, reject) => {\n      /* istanbul ignore next -- @preserve */\n      setTimeout(async () => {\n        try {\n          if (watchdog) {\n            await watchdog.destroy();\n            return resolve();\n          }\n          if (instance) {\n            await instance.destroy();\n            return resolve();\n          }\n          resolve();\n        } catch (e) {\n          console.error(e);\n          reject(e);\n        }\n      });\n    });\n  };\n  const _initializeEditor = async () => {\n    if (props.disableWatchdog) {\n      const instance = await _createEditor(props.data, _getConfig());\n      return {\n        instance,\n        watchdog: null\n      };\n    }\n    const watchdog = (() => {\n      if (isContextWatchdogReadyToUse(context)) {\n        return new EditorWatchdogAdapter(context.watchdog);\n      }\n      return new props.editor.EditorWatchdog(props.editor, props.watchdogConfig);\n    })();\n    const totalRestartsRef = {\n      current: 0\n    };\n    watchdog.setCreator(async (_, config) => {\n      const { onAfterDestroy } = props;\n      if (totalRestartsRef.current > 0 && onAfterDestroy && editorRefs.instance.current) {\n        onAfterDestroy(editorRefs.instance.current);\n      }\n      const instance = await _createEditor(data, config);\n      if (totalRestartsRef.current > 0) {\n        semaphore.unsafeSetValue({\n          instance,\n          watchdog\n        });\n        setTimeout(() => {\n          /* istanbul ignore next -- @preserve */\n          if (props.onReady) {\n            props.onReady(watchdog.editor);\n          }\n        });\n      }\n      totalRestartsRef.current++;\n      return instance;\n    });\n    watchdog.on(\"error\", (_, { error, causesRestart }) => {\n      const onError = props.onError || console.error;\n      onError(error, { phase: \"runtime\", willEditorRestart: causesRestart });\n    });\n    await watchdog.create(data, _getConfig()).catch((error) => {\n      const onError = props.onError || console.error;\n      onError(error, { phase: \"initialization\", willEditorRestart: false });\n      throw error;\n    });\n    return {\n      watchdog,\n      instance: watchdog.editor\n    };\n  };\n  const _getStateDiff = (previousState, newState) => {\n    const previousStateKeys = Object.keys(previousState);\n    const newStateKeys = Object.keys(newState);\n    return {\n      addedKeys: newStateKeys.filter((key) => !previousStateKeys.includes(key)),\n      removedKeys: previousStateKeys.filter((key) => !newStateKeys.includes(key))\n    };\n  };\n  const _externalSetData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (newData) => {\n      semaphore.runAfterMount(() => {\n        shouldUpdateEditor.current = true;\n        setData(newData);\n      });\n    },\n    [setData]\n  );\n  const _externalSetAttributes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (newAttributes) => {\n      semaphore.runAfterMount(() => {\n        shouldUpdateEditor.current = true;\n        setAttributes(newAttributes);\n      });\n    },\n    [setAttributes]\n  );\n  const toolbarElement = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    EditorToolbarWrapper,\n    {\n      ref: semaphoreElementRef,\n      editor: editorRefs.instance.current\n    }\n  );\n  useInstantEditorEffect(semaphore.current, ({ instance }) => {\n    if (props.disabled) {\n      instance.enableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID);\n    } else {\n      instance.disableReadOnlyMode(REACT_INTEGRATION_READ_ONLY_LOCK_ID);\n    }\n  }, [props.disabled]);\n  useInstantEditorEffect(semaphore.current, ({ instance }) => {\n    if (shouldUpdateEditor.current) {\n      shouldUpdateEditor.current = false;\n      const dataKeys = Object.keys(data);\n      const attributesKeys = Object.keys(attributes);\n      if (!dataKeys.every((key) => attributesKeys.includes(key))) {\n        console.error(\"`data` and `attributes` objects must have the same keys (roots).\");\n        throw new Error(\"`data` and `attributes` objects must have the same keys (roots).\");\n      }\n      const editorData = instance.getFullData();\n      const editorAttributes = instance.getRootsAttributes();\n      const {\n        addedKeys: newRoots,\n        removedKeys: removedRoots\n      } = _getStateDiff(\n        editorData,\n        data || /* istanbul ignore next -- @preserve: It should never happen, data should be always filled. */\n        {}\n      );\n      const modifiedRoots = dataKeys.filter(\n        (rootName) => editorData[rootName] !== void 0 && JSON.stringify(editorData[rootName]) !== JSON.stringify(data[rootName])\n      );\n      const rootsWithChangedAttributes = attributesKeys.filter((rootName) => JSON.stringify(editorAttributes[rootName]) !== JSON.stringify(attributes[rootName]));\n      const _handleNewRoots = (roots2) => {\n        roots2.forEach((rootName) => {\n          instance.addRoot(rootName, {\n            data: data[rootName] || \"\",\n            attributes: (attributes == null ? void 0 : attributes[rootName]) || /* istanbul ignore next -- @preserve: attributes should be in sync with root keys */\n            {},\n            isUndoable: true\n          });\n        });\n      };\n      const _handleRemovedRoots = (roots2) => {\n        roots2.forEach((rootName) => {\n          instance.detachRoot(rootName, true);\n        });\n      };\n      const _updateEditorData = (roots2) => {\n        const dataToUpdate = roots2.reduce(\n          (result, rootName) => ({ ...result, [rootName]: data[rootName] }),\n          /* @__PURE__ */ Object.create(null)\n        );\n        instance.data.set(dataToUpdate, { suppressErrorInCollaboration: true });\n      };\n      const _updateEditorAttributes = (writer, roots2) => {\n        roots2.forEach((rootName) => {\n          Object.keys(attributes[rootName]).forEach((attr) => {\n            instance.registerRootAttribute(attr);\n          });\n          writer.clearAttributes(instance.model.document.getRoot(rootName));\n          writer.setAttributes(attributes[rootName], instance.model.document.getRoot(rootName));\n        });\n      };\n      setTimeout(() => {\n        instance.model.change((writer) => {\n          _handleNewRoots(newRoots);\n          _handleRemovedRoots(removedRoots);\n          if (modifiedRoots.length) {\n            _updateEditorData(modifiedRoots);\n          }\n          if (rootsWithChangedAttributes.length) {\n            _updateEditorAttributes(writer, rootsWithChangedAttributes);\n          }\n        });\n      });\n    }\n  }, [data, attributes]);\n  const editableElements = roots.map(\n    (rootName) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n      EditorEditable,\n      {\n        key: rootName,\n        id: rootName,\n        rootName,\n        semaphore\n      }\n    )\n  );\n  return {\n    editor: editorRefs.instance.current,\n    editableElements,\n    toolbarElement,\n    data,\n    setData: _externalSetData,\n    attributes,\n    setAttributes: _externalSetAttributes\n  };\n};\nconst EditorEditable = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)((0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ id, semaphore, rootName }, ref) => {\n  const innerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    let editable;\n    let editor;\n    semaphore.runAfterMount(({ instance }) => {\n      if (!innerRef.current) {\n        return;\n      }\n      editor = instance;\n      const { ui, model } = editor;\n      const root = model.document.getRoot(rootName);\n      if (root && editor.ui.getEditableElement(rootName)) {\n        editor.detachEditable(root);\n      }\n      editable = ui.view.createEditable(rootName, innerRef.current);\n      ui.addEditable(editable);\n      instance.editing.view.forceRender();\n    });\n    return () => {\n      /* istanbul ignore next -- @preserve: It depends on the version of the React and may not happen all of the times. */\n      if (editor && editor.state !== \"destroyed\" && innerRef.current) {\n        const root = editor.model.document.getRoot(rootName);\n        /* istanbul ignore else -- @preserve */\n        if (root) {\n          editor.detachEditable(root);\n        }\n      }\n    };\n  }, [semaphore.revision]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    \"div\",\n    {\n      key: semaphore.revision,\n      id,\n      ref: mergeRefs(ref, innerRef)\n    }\n  );\n}));\nEditorEditable.displayName = \"EditorEditable\";\nconst EditorToolbarWrapper = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ editor }, ref) => {\n  const toolbarRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const toolbarContainer = toolbarRef.current;\n    if (!editor || !toolbarContainer) {\n      return void 0;\n    }\n    const element = editor.ui.view.toolbar.element;\n    toolbarContainer.appendChild(element);\n    return () => {\n      if (toolbarContainer.contains(element)) {\n        toolbarContainer.removeChild(element);\n      }\n    };\n  }, [editor && editor.id]);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: mergeRefs(toolbarRef, ref) });\n});\nEditorToolbarWrapper.displayName = \"EditorToolbarWrapper\";\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useIsUnmountedRef = () => {\n  const mountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    mountedRef.current = false;\n    return () => {\n      mountedRef.current = true;\n    };\n  }, []);\n  return mountedRef;\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useAsyncCallback = (callback) => {\n  const [asyncState, setAsyncState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n    status: \"idle\"\n  });\n  const unmountedRef = useIsUnmountedRef();\n  const prevExecutionUIDRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const asyncExecutor = useRefSafeCallback(async (...args) => {\n    if (unmountedRef.current || (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.isSSR)()) {\n      return null;\n    }\n    const currentExecutionUUID = (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.uid)();\n    prevExecutionUIDRef.current = currentExecutionUUID;\n    try {\n      if (asyncState.status !== \"loading\") {\n        setAsyncState({\n          status: \"loading\"\n        });\n      }\n      const result = await callback(...args);\n      if (!unmountedRef.current && prevExecutionUIDRef.current === currentExecutionUUID) {\n        setAsyncState({\n          status: \"success\",\n          data: result\n        });\n      }\n      return result;\n    } catch (error) {\n      console.error(error);\n      if (!unmountedRef.current && prevExecutionUIDRef.current === currentExecutionUUID) {\n        setAsyncState({\n          status: \"error\",\n          error\n        });\n      }\n    }\n    return null;\n  });\n  return [asyncExecutor, asyncState];\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst useAsyncValue = (callback, deps) => {\n  const [asyncCallback, asyncState] = useAsyncCallback(callback);\n  useInstantEffect(asyncCallback, deps);\n  if (asyncState.status === \"idle\") {\n    return {\n      status: \"loading\"\n    };\n  }\n  return asyncState;\n};\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nfunction useCKEditorCloud(config) {\n  const serializedConfigKey = JSON.stringify(config);\n  const result = useAsyncValue(\n    async () => (0,_ckeditor_ckeditor5_integrations_common__WEBPACK_IMPORTED_MODULE_1__.loadCKEditorCloud)(config),\n    [serializedConfigKey]\n  );\n  if (result.status === \"success\") {\n    return {\n      ...result.data,\n      status: \"success\"\n    };\n  }\n  return result;\n}\n/**\n * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options\n */\nconst withCKEditorCloud = (config) => (WrappedComponent) => {\n  const ComponentWithCKEditorCloud = (props) => {\n    var _a, _b;\n    const ckeditorCloudResult = useCKEditorCloud(config.cloud);\n    switch (ckeditorCloudResult.status) {\n      case \"error\":\n        if (!config.renderError) {\n          return \"Unable to load CKEditor Cloud data!\";\n        }\n        return config.renderError(ckeditorCloudResult.error);\n      case \"success\":\n        return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(WrappedComponent, { ...props, cloud: ckeditorCloudResult });\n      default:\n        return (_b = (_a = config.renderLoader) == null ? void 0 : _a.call(config)) != null ? _b : null;\n    }\n  };\n  ComponentWithCKEditorCloud.displayName = \"ComponentWithCKEditorCloud\";\n  return ComponentWithCKEditorCloud;\n};\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AY2tlZGl0b3IvY2tlZGl0b3I1LXJlYWN0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDc0c7QUFDNko7QUFDaks7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUNBQXFDLHFCQUFxQix1Q0FBdUM7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx5QkFBeUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYSxLQUFLLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlCQUF5QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UseUJBQXlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxnQkFBZ0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGdCQUFnQjtBQUNoRiw0RUFBNEUsbURBQW1EO0FBQy9IO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQSwrREFBK0QsbUJBQW1CO0FBQ2xGO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYywrQkFBK0IsbUJBQW1CO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELG1EQUFtRDtBQUNsSDtBQUNBLG1DQUFtQyw2RUFBSTtBQUN2QyxjQUFjLDZDQUE2QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULFFBQVE7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdEQUFtQixxQkFBcUIsc0NBQXNDO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGNrZWRpdG9yL2NrZWRpdG9yNS1yZWFjdC9kaXN0L2luZGV4LmpzPzU3MzciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlLCBtZW1vLCBmb3J3YXJkUmVmLCB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjcmVhdGVEZWZlciwgb25jZSwgdWlkLCBjcmVhdGVJbnRlZ3JhdGlvblVzYWdlRGF0YVBsdWdpbiwgaXNDS0VkaXRvckZyZWVMaWNlbnNlLCBhcHBlbmRFeHRyYVBsdWdpbnNUb0VkaXRvckNvbmZpZywgc2hhbGxvd0NvbXBhcmVBcnJheXMsIG92ZXJ3cml0ZU9iamVjdCwgb3ZlcndyaXRlQXJyYXksIHVuaXEsIGlzU1NSLCBsb2FkQ0tFZGl0b3JDbG91ZCB9IGZyb20gXCJAY2tlZGl0b3IvY2tlZGl0b3I1LWludGVncmF0aW9ucy1jb21tb25cIjtcbmltcG9ydCB7IGxvYWRDS0VkaXRvckNsb3VkIGFzIGxvYWRDS0VkaXRvckNsb3VkMiB9IGZyb20gXCJAY2tlZGl0b3IvY2tlZGl0b3I1LWludGVncmF0aW9ucy1jb21tb25cIjtcbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuY29uc3QgX0xpZmVDeWNsZUVsZW1lbnRTZW1hcGhvcmUgPSBjbGFzcyBfTGlmZUN5Y2xlRWxlbWVudFNlbWFwaG9yZSB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGxpZmVjeWNsZSkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgc2hvdWxkIGRlZmluZSBhc3luYyBtZXRob2RzIGZvciBpbml0aWFsaXppbmcgYW5kIGRlc3Ryb3lpbmcgdGhlIGVkaXRvci5cbiAgICAgKiBFc3NlbnRpYWxseSwgaXQncyBhbiBhc3luYyB2ZXJzaW9uIG9mIGJhc2ljIFJlYWN0IGxpZmVjeWNsZSBtZXRob2RzIGxpa2UgYGNvbXBvbmVudERpZE1vdW50YCwgYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cbiAgICAgKlxuICAgICAqIFx0KiBSZXN1bHQgb2Yge0BsaW5rIExpZmVDeWNsZUFzeW5jT3BlcmF0b3JzI21vdW50fSBtZXRob2QgaXMgcGFzc2VkIHRvIHtAbGluayBMaWZlQ3ljbGVBc3luY09wZXJhdG9ycyN1bm1vdW50fSBhcyBhbiBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2xpZmVjeWNsZVwiKTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBlbGVtZW50IGluc3RhbmNlIHRoYXQgdGhlIGVkaXRvciB1c2VzIGZvciBtb3VudGluZy4gVGhpcyBlbGVtZW50IHNob3VsZCBjb250YWluIHRoZSBgY2tlZGl0b3JJbnN0YW5jZWAgbWVtYmVyXG4gICAgICogb25jZSB0aGUgZWRpdG9yIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBtb3VudGVkIHRvIGl0LiBUaGUgc2VtYXBob3JlIGVuc3VyZXMgdGhhdCBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgZWRpdG9yLCB3aGljaCB3aWxsXG4gICAgICogYmUgYXNzaWduZWQgdG8gdGhpcyBlbGVtZW50IGJ5IHRoZSB7QGxpbmsgI19saWZlY3ljbGU6bW91bnR9IG1ldGhvZCwgd2lsbCBhbHdheXMgYmUgaW5pdGlhbGl6ZWQgYWZ0ZXIgdGhlIHN1Y2Nlc3NmdWxcbiAgICAgKiBkZXN0cnVjdGlvbiBvZiB0aGUgdW5kZXJseWluZyBgY2tlZGl0b3JJbnN0YW5jZWAgdGhhdCB3YXMgcHJldmlvdXNseSBtb3VudGVkIG9uIHRoaXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2VsZW1lbnRcIik7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgbG9jayBtZWNoYW5pc20gdXRpbGl6ZWQgYnkgdGhlIHtAbGluayAjbG9ja30gYW5kIHtAbGluayAjcmVsZWFzZX0gbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIFx0KiBJZiB0aGUgZWRpdG9yIGlzIG5vdCB5ZXQgbW91bnRlZCBhbmQgaXMgYXdhaXRpbmcgbW91bnRpbmcgKGZvciBpbnN0YW5jZSwgd2hlbiBhbm90aGVyIGVkaXRvciBpc1xuICAgICAqIFx0ICBvY2N1cHlpbmcgdGhlIGVsZW1lbnQpLCB0aGVuIGl0IGlzIG51bGwuXG4gICAgICpcbiAgICAgKiBcdCogV2hlbiB0aGUgZWRpdG9yIGlzIG1vdW50ZWQgb24gdGhlIGVsZW1lbnQsIHRoaXMgdmFyaWFibGUgaG9sZHMgYW4gdW5yZXNvbHZlZCBwcm9taXNlIHRoYXQgd2lsbCBiZVxuICAgICAqIFx0ICByZXNvbHZlZCBhZnRlciB0aGUgZWRpdG9yIGlzIGRlc3Ryb3llZC5cbiAgICAgKlxuICAgICAqIFx0KiBPbmNlIHRoZSBlZGl0b3IgaXMgZGVzdHJveWVkIChhbmQgaXQgd2FzIHByZXZpb3VzbHkgbW91bnRlZCksIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkLlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcmVsZWFzZUxvY2tcIiwgbnVsbCk7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgcmVzdWx0IG9mIHRoZSB7QGxpbmsgI19saWZlY3ljbGU6bW91bnR9IGZ1bmN0aW9uLiBUaGlzIHZhbHVlIHNob3VsZCBiZSByZXNldCB0byBgbnVsbGBcbiAgICAgKiBvbmNlIHRoZSBzZW1hcGhvcmUgaXMgcmVsZWFzZWQuIEl0IGlzIHV0aWxpemVkIHRvIHN0b3JlIGNlcnRhaW4gZGF0YSB0aGF0IG11c3QgYmUgcmVtb3ZlZCBmb2xsb3dpbmdcbiAgICAgKiB0aGUgZGVzdHJ1Y3Rpb24gb2YgdGhlIGVkaXRvci4gVGhpcyBkYXRhIG1heSBpbmNsdWRlIHRoZSBlZGl0b3IncyBpbnN0YW5jZSwgdGhlIGFzc2lnbmVkIHdhdGNoZG9nLFxuICAgICAqIG9yIGhhbmRsZXMgZm9yIGFkZGl0aW9uYWwgd2luZG93IGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3ZhbHVlXCIsIG51bGwpO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBsaXN0IG9mIGNhbGxiYWNrcyB0aGF0IGFyZSB0cmlnZ2VyZWQgaWYgdGhlIHNlbWFwaG9yZSB7QGxpbmsgI19saWZlY3ljbGU6bW91bnR9IG1ldGhvZCBleGVjdXRlcyBzdWNjZXNzZnVsbHkuXG4gICAgICogSXQgaXMgdXRpbGl6ZWQgaW4gc2NlbmFyaW9zIHdoZXJlIHdlIG5lZWQgdG8gYXNzaWduIGNlcnRhaW4gcHJvcGVydGllcyB0byBhbiBlZGl0b3IgdGhhdCBpcyBjdXJyZW50bHkgaW4gdGhlIHByb2Nlc3Mgb2YgbW91bnRpbmcuXG4gICAgICogQW4gaW5zdGFuY2Ugb2Ygc3VjaCB1c2FnZSBjb3VsZCBiZSB0d28td2F5IGJpbmRpbmcuIFdlIGFpbSB0byBwcmV2ZW50IHRoZSBsb3NzIG9mIGFsbCBgc2V0RGF0YWAgY2FsbHMgaWYgdGhlIGVkaXRvciBoYXMgbm90XG4gICAgICogeWV0IGJlZW4gbW91bnRlZCwgdGhlcmVmb3JlIHRoZXNlIGNhbGxzIHdpbGwgYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkgZm9sbG93aW5nIHRoZSBjb21wbGV0aW9uIG9mIHRoZSBtb3VudGluZyBwcm9jZXNzLlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfYWZ0ZXJNb3VudENhbGxiYWNrc1wiLCBbXSk7XG4gICAgLyoqXG4gICAgICogVGhpcyByZXByZXNlbnRzIHRoZSBhY3R1YWwgbW91bnRpbmcgc3RhdGUgb2YgdGhlIHNlbWFwaG9yZS4gSXQgaXMgcHJpbWFyaWx5IHVzZWQgYnkgdGhlIHtAbGluayAjcmVsZWFzZX0gbWV0aG9kIHRvXG4gICAgICogZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGluaXRpYWxpemF0aW9uIG9mIHRoZSBlZGl0b3Igc2hvdWxkIGJlIHNraXBwZWQgb3IsIGlmIHRoZSBlZGl0b3IgaXMgYWxyZWFkeSBpbml0aWFsaXplZCwgdGhlIGVkaXRvclxuICAgICAqIHNob3VsZCBiZSBkZXN0cm95ZWQuXG4gICAgICpcbiAgICAgKiBcdCogSWYgYGRlc3Ryb3llZEJlZm9yZUluaXRpYWxpemF0aW9uYCBpcyB0cnVlLCB0aGVuIHRoZSB7QGxpbmsgI3JlbGVhc2V9IG1ldGhvZCB3YXMgaW52b2tlZCBiZWZvcmUgdGhlIGVkaXRvciBiZWdhbiB0byBtb3VudC5cbiAgICAgKiBcdCAgVGhpcyBvZnRlbiBvY2N1cnMgaW4gc3RyaWN0IG1vZGUgd2hlbiB3ZSBhc3NpZ24gYSBwcm9taXNlIHRvIHRoZSB7QGxpbmsgTGlmZUN5Y2xlRWRpdG9yRWxlbWVudFNlbWFwaG9yZSNfc2VtYXBob3Jlc30gbWFwXG4gICAgICogXHQgIGFuZCB0aGUgYXNzaWduZWQgYG1vdW50YCBjYWxsYmFjayBoYXMgbm90IHlldCBiZWVuIGNhbGxlZC4gSW4gdGhpcyBzY2VuYXJpbywgaXQgaXMgc2FmZSB0byBza2lwIHRoZSBpbml0aWFsaXphdGlvbiBvZiB0aGUgZWRpdG9yXG4gICAgICogXHQgIGFuZCBzaW1wbHkgcmVsZWFzZSB0aGUgc2VtYXBob3JlLlxuICAgICAqXG4gICAgICpcdCogSWYgYG1vdW50aW5nSW5Qcm9ncmVzc2AgaXMgYSBQcm9taXNlLCB0aGVuIHRoZSB7QGxpbmsgI3JlbGVhc2V9IG1ldGhvZCB3YXMgaW52b2tlZCBhZnRlciB0aGUgaW5pdGlhbGl6YXRpb24gb2YgdGhlIGVkaXRvciBhbmRcbiAgICAgXHQgIHRoZSBlZGl0b3IgbXVzdCBiZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBzZW1hcGhvcmUgaXMgcmVsZWFzZWQuXG4gICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3N0YXRlXCIsIHtcbiAgICAgIGRlc3Ryb3llZEJlZm9yZUluaXRpYWxpemF0aW9uOiBmYWxzZSxcbiAgICAgIG1vdW50aW5nSW5Qcm9ncmVzczogbnVsbFxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEludmVyc2Ugb2Yge0BsaW5rICNfbG9ja30gbWV0aG9kIHRoYXQgdHJpZXMgdG8gZGVzdHJveSBhdHRhY2hlZCBlZGl0b3IuXG4gICAgICpcbiAgICAgKiBcdCogSWYgZWRpdG9yIGlzIGJlaW5nIGFscmVhZHkgYXR0YWNoZWQgdG8gZWxlbWVudCAob3IgaXMgaW4gYXR0YWNoaW5nIHByb2Nlc3MpIHRoZW4gYWZ0ZXIgZnVsbHkgaW5pdGlhbGl6YXRpb24gb2YgZWRpdG9yXG4gICAgICogXHQgIGRlc3Ryb3kgaXMgcGVyZm9ybWVkIGFuZCBzZW1hcGhvcmUgaXMgcmVsZWFzZWQuIFRoZSB7QGxpbmsgI19saWZlY3ljbGV9IHVubW91bnQgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIFx0KiBJZiBlZGl0b3IgaXMgYmVpbmcgZGVzdHJveWVkIGJlZm9yZSBpbml0aWFsaXphdGlvbiB0aGVuIGl0IGRvZXMgbm90aGluZyBidXQgc2V0cyBgZGVzdHJveWVkQmVmb3JlSW5pdGlhbGl6YXRpb25gIGZsYWcgdGhhdFxuICAgICAqIFx0ICB3aWxsIGJlIGxhdGVyIGNoZWNrZWQgYnkge0BsaW5rICNfbG9ja30gbWV0aG9kIGluIGluaXRpYWxpemF0aW9uLiBUaGUge0BsaW5rICNfbGlmZWN5Y2xlfSB1bm1vdW50IG1ldGhvZCBpcyBub3QgY2FsbGVkLlxuICAgICAqXG4gICAgICogKkltcG9ydGFudCBub3RlOipcbiAgICAgKlxuICAgICAqIEl04oCZcyByZWFsbHkgaW1wb3J0YW50IHRvIGtlZXAgdGhpcyBtZXRob2QgKnN5bmMqLiBJZiB3ZSBtYWtlIHRoaXMgbWV0aG9kICphc3luYyosIGl0IHdvbuKAmXQgd29yayB3ZWxsIGJlY2F1c2VcbiAgICAgKiBpdCB3aWxsIGNhdXNlIHByb2JsZW1zIHdoZW4gd2XigJlyZSB0cnlpbmcgdG8gc2V0IHVwIHRoZSB7QGxpbmsgTGlmZUN5Y2xlRWRpdG9yRWxlbWVudFNlbWFwaG9yZSNfc2VtYXBob3Jlc30gbWFwIGVudHJpZXMuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlbGVhc2VcIiwgb25jZSgoKSA9PiB7XG4gICAgICBjb25zdCB7IF9yZWxlYXNlTG9jaywgX3N0YXRlLCBfZWxlbWVudCwgX2xpZmVjeWNsZSB9ID0gdGhpcztcbiAgICAgIGlmIChfc3RhdGUubW91bnRpbmdJblByb2dyZXNzKSB7XG4gICAgICAgIF9zdGF0ZS5tb3VudGluZ0luUHJvZ3Jlc3MudGhlbigoKSA9PiBfbGlmZWN5Y2xlLnVubW91bnQoe1xuICAgICAgICAgIGVsZW1lbnQ6IF9lbGVtZW50LFxuICAgICAgICAgIC8vIE1vdW50IHJlc3VsdCBtaWdodCBiZSBvdmVycmlkZGVuIGJ5IHdhdGNoZG9nIGR1cmluZyByZXN0YXJ0IHNvIHVzZSBpbnN0YW5jZSB2YXJpYWJsZS5cbiAgICAgICAgICBtb3VudFJlc3VsdDogdGhpcy52YWx1ZVxuICAgICAgICB9KSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkNLRWRpdG9yIHVubW91bnRpbmcgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgfSkudGhlbihfcmVsZWFzZUxvY2sucmVzb2x2ZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9zdGF0ZS5kZXN0cm95ZWRCZWZvcmVJbml0aWFsaXphdGlvbiA9IHRydWU7XG4gICAgICAgIF9yZWxlYXNlTG9jay5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX2xpZmVjeWNsZSA9IGxpZmVjeWNsZTtcbiAgICB0aGlzLl9sb2NrKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3Ige0BsaW5rICNfdmFsdWV9LlxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVzZXRzIHRoZSBzZW1hcGhvcmUgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG4gICAqL1xuICBkaXNjYXJkKCkge1xuICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICB0aGlzLl9yZWxlYXNlTG9jayA9IG51bGw7XG4gICAgdGhpcy5fYWZ0ZXJNb3VudENhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMuX3N0YXRlID0ge1xuICAgICAgZGVzdHJveWVkQmVmb3JlSW5pdGlhbGl6YXRpb246IGZhbHNlLFxuICAgICAgbW91bnRpbmdJblByb2dyZXNzOiBudWxsXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogT2NjYXNpb25hbGx5LCB0aGUgV2F0Y2hkb2cgcmVzdGFydHMgdGhlIGVkaXRvciBpbnN0YW5jZSwgcmVzdWx0aW5nIGluIGEgbmV3IGluc3RhbmNlIGJlaW5nIGFzc2lnbmVkIHRvIHRoZSBzZW1hcGhvcmUuXG4gICAqIEluIHRlcm1zIG9mIHJhY2UgY29uZGl0aW9ucywgaXQncyBnZW5lcmFsbHkgc2FmZXIgdG8gc2ltcGx5IG92ZXJyaWRlIHRoZSBzZW1hcGhvcmUgdmFsdWUgcmF0aGVyIHRoYW4gcmVjcmVhdGluZyBpdFxuICAgKiB3aXRoIGEgZGlmZmVyZW50IG9uZS5cbiAgICovXG4gIHVuc2FmZVNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLl9hZnRlck1vdW50Q2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAodGhpcy5fbGlmZWN5Y2xlLmlzVmFsdWVWYWxpZCAmJiAhdGhpcy5fbGlmZWN5Y2xlLmlzVmFsdWVWYWxpZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sodmFsdWUpO1xuICAgIH0pO1xuICAgIHRoaXMuX2FmdGVyTW91bnRDYWxsYmFja3MgPSBbXTtcbiAgfVxuICAvKipcbiAgICogVGhpcyByZWdpc3RlcnMgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkIGFmdGVyIHRoZSBlZGl0b3IgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IG1vdW50ZWQuXG4gICAqXG4gICAqIFx0KiBJZiB0aGUgZWRpdG9yIGlzIGFscmVhZHkgbW91bnRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkuXG4gICAqXHQqIElmIHRoZSBlZGl0b3IgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgbW91bnRpbmcsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIHVwb24gc3VjY2Vzc2Z1bCBtb3VudGluZy5cbiAgKiBcdCogSWYgdGhlIGVkaXRvciBpcyBuZXZlciBtb3VudGVkLCB0aGUgcGFzc2VkIGNhbGxiYWNrIHdpbGwgbm90IGJlIGV4ZWN1dGVkLlxuICAqIFx0KiBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIHdpdGhpbiB0aGUgY2FsbGJhY2ssIGl0IHdpbGwgYmUgcmUtdGhyb3duIGluIHRoZSBzZW1hcGhvcmUuXG4gICogXHQqIElmIHRoZSB2YWx1ZSBpcyBub3QgdmFsaWQgKGRldGVybWluZWQgYnkgaXNWYWx1ZVZhbGlkKSwgdGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGV4ZWN1dGVkLlxuICAqL1xuICBydW5BZnRlck1vdW50KGNhbGxiYWNrKSB7XG4gICAgY29uc3QgeyBfdmFsdWUsIF9hZnRlck1vdW50Q2FsbGJhY2tzIH0gPSB0aGlzO1xuICAgIGlmIChfdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9saWZlY3ljbGUuaXNWYWx1ZVZhbGlkICYmICF0aGlzLl9saWZlY3ljbGUuaXNWYWx1ZVZhbGlkKF92YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soX3ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2FmdGVyTW91bnRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGluZm9ybSBvdGhlciBjb21wb25lbnRzIHRoYXQgdGhlIHtAbGluayAjX2VsZW1lbnR9IHdpbGwgYmUgdXNlZCBieSB0aGUgZWRpdG9yLFxuICAgKiB3aGljaCBpcyBpbml0aWFsaXplZCBieSB0aGUge0BsaW5rICNfbGlmZWN5Y2xlfSBtZXRob2RzLlxuICAgKlxuICAgKiBcdCogSWYgYW4gZWRpdG9yIGlzIGFscmVhZHkgcHJlc2VudCBvbiB0aGUgcHJvdmlkZWQgZWxlbWVudCwgdGhlIGluaXRpYWxpemF0aW9uIG9mIHRoZSBjdXJyZW50IG9uZVxuICAgKiBcdCAgd2lsbCBiZSBwb3N0cG9uZWQgdW50aWwgdGhlIHByZXZpb3VzIG9uZSBpcyBkZXN0cm95ZWQuXG4gICAqXG4gICAqIFx0KiBJZiB0aGUgZWxlbWVudCBpcyBlbXB0eSBhbmQgZG9lcyBub3QgaGF2ZSBhbiBlZGl0b3IgYXR0YWNoZWQgdG8gaXQsIHRoZSBjdXJyZW50bHkgbG9ja2VkIGVkaXRvciB3aWxsXG4gICAqIFx0ICBiZSBtb3VudGVkIGltbWVkaWF0ZWx5LlxuICAgKlxuICAgKiBBZnRlciB0aGUgc3VjY2Vzc2Z1bCBpbml0aWFsaXphdGlvbiBvZiB0aGUgZWRpdG9yIGFuZCB0aGUgYXNzaWdubWVudCBvZiB0aGUge0BsaW5rICNfdmFsdWV9IG1lbWJlcixcbiAgICogdGhlIGBvblJlYWR5YCBsaWZlY3ljbGUgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICpcbiAgICogKkltcG9ydGFudCBub3RlOipcbiAgICpcbiAgICogSXTigJlzIHJlYWxseSBpbXBvcnRhbnQgdG8ga2VlcCB0aGlzIG1ldGhvZCAqc3luYyouIElmIHdlIG1ha2UgdGhpcyBtZXRob2QgKmFzeW5jKiwgaXQgd29u4oCZdCB3b3JrIHdlbGwgYmVjYXVzZVxuICAgKiBpdCB3aWxsIGNhdXNlIHByb2JsZW1zIHdoZW4gd2XigJlyZSB0cnlpbmcgdG8gc2V0IHVwIHRoZSB7QGxpbmsgTGlmZUN5Y2xlRWRpdG9yRWxlbWVudFNlbWFwaG9yZSNfc2VtYXBob3Jlc30gbWFwIGVudHJpZXMuXG4gICAqL1xuICBfbG9jaygpIHtcbiAgICBjb25zdCB7IF9zZW1hcGhvcmVzIH0gPSBfTGlmZUN5Y2xlRWxlbWVudFNlbWFwaG9yZTtcbiAgICBjb25zdCB7IF9zdGF0ZSwgX2VsZW1lbnQsIF9saWZlY3ljbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgcHJldkVsZW1lbnRTZW1hcGhvcmUgPSBfc2VtYXBob3Jlcy5nZXQoX2VsZW1lbnQpIHx8IFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICBjb25zdCByZWxlYXNlTG9jayA9IGNyZWF0ZURlZmVyKCk7XG4gICAgdGhpcy5fcmVsZWFzZUxvY2sgPSByZWxlYXNlTG9jaztcbiAgICBjb25zdCBuZXdFbGVtZW50U2VtYXBob3JlID0gcHJldkVsZW1lbnRTZW1hcGhvcmUudGhlbigoKSA9PiB7XG4gICAgICBpZiAoX3N0YXRlLmRlc3Ryb3llZEJlZm9yZUluaXRpYWxpemF0aW9uKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodm9pZCAwKTtcbiAgICAgIH1cbiAgICAgIF9zdGF0ZS5tb3VudGluZ0luUHJvZ3Jlc3MgPSBfbGlmZWN5Y2xlLm1vdW50KCkudGhlbigobW91bnRSZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKG1vdW50UmVzdWx0KSB7XG4gICAgICAgICAgdGhpcy51bnNhZmVTZXRWYWx1ZShtb3VudFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdW50UmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gX3N0YXRlLm1vdW50aW5nSW5Qcm9ncmVzcztcbiAgICB9KS50aGVuKGFzeW5jIChtb3VudFJlc3VsdCkgPT4ge1xuICAgICAgaWYgKG1vdW50UmVzdWx0ICYmIF9saWZlY3ljbGUuYWZ0ZXJNb3VudCkge1xuICAgICAgICBhd2FpdCBfbGlmZWN5Y2xlLmFmdGVyTW91bnQoe1xuICAgICAgICAgIGVsZW1lbnQ6IF9lbGVtZW50LFxuICAgICAgICAgIG1vdW50UmVzdWx0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLnRoZW4oKCkgPT4gcmVsZWFzZUxvY2sucHJvbWlzZSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQ0tFZGl0b3IgbW91bnRpbmcgZXJyb3I6XCIsIGVycm9yKTtcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIGlmIChfc2VtYXBob3Jlcy5nZXQoX2VsZW1lbnQpID09PSBuZXdFbGVtZW50U2VtYXBob3JlKSB7XG4gICAgICAgIF9zZW1hcGhvcmVzLmRlbGV0ZShfZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3NlbWFwaG9yZXMuc2V0KF9lbGVtZW50LCBuZXdFbGVtZW50U2VtYXBob3JlKTtcbiAgfVxufTtcbi8qKlxuICogVGhpcyBpcyBhIG1hcCBvZiBlbGVtZW50cyBhc3NvY2lhdGVkIHdpdGggcHJvbWlzZXMuIEl0IGluZm9ybXMgdGhlIHNlbWFwaG9yZSB0aGF0IHRoZSB1bmRlcmx5aW5nIEhUTUwgZWxlbWVudCwgdXNlZCBhcyBhIGtleSxcbiAqIGlzIGN1cnJlbnRseSBpbiB1c2UgYnkgYW5vdGhlciBlZGl0b3IuIEVhY2ggZWxlbWVudCBpcyBhc3NpZ25lZCBhIHByb21pc2UsIHdoaWNoIGFsbG93cyBmb3IgdGhlIGVhc3kgY2hhaW5pbmcgb2YgbmV3XG4gKiBlZGl0b3IgaW5zdGFuY2VzIG9uIGFuIGVsZW1lbnQgdGhhdCBpcyBhbHJlYWR5IGluIHVzZSBieSBhbm90aGVyIGluc3RhbmNlLiBUaGUgcHJvY2VzcyB3b3JrcyBhcyBmb2xsb3dzOlxuICpcbiAqIFx0MS4gSWYgYW4gZWxlbWVudCBpcyBiZWluZyB1c2VkIGJ5IGFuIGVkaXRvciwgdGhlbiB0aGUgaW5pdGlhbGl6YXRpb24gb2YgYSBuZXcgZWRpdG9yXG4gKiBcdCAgIGluc3RhbmNlIGlzIGNoYWluZWQgdXNpbmcgdGhlIGAudGhlbigpYCBtZXRob2Qgb2YgdGhlIFByb21pc2UuXG4gKlxuICogXHQyLiBJZiB0aGUgZWRpdG9yIGFzc29jaWF0ZWQgd2l0aCB0aGUgdW5kZXJseWluZyBlbGVtZW50IGlzIGRlc3Ryb3llZCwgdGhlbiBgUHJvbWlzZS5yZXNvbHZlKClgIGlzIGNhbGxlZFxuICogXHQgICBhbmQgdGhlIHByZXZpb3VzbHkgYXNzaWduZWQgYC50aGVuKClgIGVkaXRvciBjYWxsYmFjayBpcyBleGVjdXRlZC5cbiAqXG4gKiAgQHNlZSB7QGxpbmsgI2xvY2t9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHRoZSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuX19wdWJsaWNGaWVsZChfTGlmZUN5Y2xlRWxlbWVudFNlbWFwaG9yZSwgXCJfc2VtYXBob3Jlc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbmxldCBMaWZlQ3ljbGVFbGVtZW50U2VtYXBob3JlID0gX0xpZmVDeWNsZUVsZW1lbnRTZW1hcGhvcmU7XG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmNvbnN0IFJlYWN0Q29udGV4dE1ldGFkYXRhS2V5ID0gXCIkX19DS0VkaXRvclJlYWN0Q29udGV4dE1ldGFkYXRhXCI7XG5mdW5jdGlvbiB3aXRoQ0tFZGl0b3JSZWFjdENvbnRleHRNZXRhZGF0YShtZXRhZGF0YSwgY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgLi4uY29uZmlnLFxuICAgIFtSZWFjdENvbnRleHRNZXRhZGF0YUtleV06IG1ldGFkYXRhXG4gIH07XG59XG5mdW5jdGlvbiB0cnlFeHRyYWN0Q0tFZGl0b3JSZWFjdENvbnRleHRNZXRhZGF0YShvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdC5nZXQoUmVhY3RDb250ZXh0TWV0YWRhdGFLZXkpO1xufVxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyNSwgQ0tTb3VyY2UgSG9sZGluZyBzcC4geiBvLm8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1saWNlbnNpbmctb3B0aW9uc1xuICovXG5jb25zdCB1c2VJc01vdW50ZWRSZWYgPSAoKSA9PiB7XG4gIGNvbnN0IG1vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG1vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG1vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIG1vdW50ZWRSZWY7XG59O1xuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyNSwgQ0tTb3VyY2UgSG9sZGluZyBzcC4geiBvLm8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1saWNlbnNpbmctb3B0aW9uc1xuICovXG5jb25zdCB1c2VSZWZTYWZlQ2FsbGJhY2sgPSAoZm4pID0+IHtcbiAgY29uc3QgY2FsbGJhY2tSZWYgPSB1c2VSZWYoKTtcbiAgY2FsbGJhY2tSZWYuY3VycmVudCA9IGZuO1xuICByZXR1cm4gdXNlQ2FsbGJhY2soXG4gICAgKC4uLmFyZ3MpID0+IGNhbGxiYWNrUmVmLmN1cnJlbnQoLi4uYXJncyksXG4gICAgW11cbiAgKTtcbn07XG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmNvbnN0IHVzZUluaXRpYWxpemVkQ0tFZGl0b3JzTWFwID0gKHtcbiAgY3VycmVudENvbnRleHRXYXRjaGRvZyxcbiAgb25DaGFuZ2VJbml0aWFsaXplZEVkaXRvcnNcbn0pID0+IHtcbiAgY29uc3Qgb25DaGFuZ2VJbml0aWFsaXplZEVkaXRvcnNTYWZlID0gdXNlUmVmU2FmZUNhbGxiYWNrKG9uQ2hhbmdlSW5pdGlhbGl6ZWRFZGl0b3JzIHx8ICgoKSA9PiB7XG4gIH0pKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGN1cnJlbnRDb250ZXh0V2F0Y2hkb2cuc3RhdHVzICE9PSBcImluaXRpYWxpemVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyB3YXRjaGRvZyB9ID0gY3VycmVudENvbnRleHRXYXRjaGRvZztcbiAgICBjb25zdCBlZGl0b3JzID0gKF9hID0gd2F0Y2hkb2cgPT0gbnVsbCA/IHZvaWQgMCA6IHdhdGNoZG9nLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5lZGl0b3JzO1xuICAgIGlmICghZWRpdG9ycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBnZXRJbml0aWFsaXplZENvbnRleHRFZGl0b3JzID0gKCkgPT4gWy4uLmVkaXRvcnNdLnJlZHVjZShcbiAgICAgIChtYXAsIGVkaXRvcikgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBpZiAoZWRpdG9yLnN0YXRlICE9PSBcInJlYWR5XCIpIHtcbiAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdHJ5RXh0cmFjdENLRWRpdG9yUmVhY3RDb250ZXh0TWV0YWRhdGEoZWRpdG9yLmNvbmZpZyk7XG4gICAgICAgIGNvbnN0IG5hbWVPcklkID0gKF9hMiA9IG1ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBtZXRhZGF0YS5uYW1lKSAhPSBudWxsID8gX2EyIDogZWRpdG9yLmlkO1xuICAgICAgICBtYXBbbmFtZU9ySWRdID0ge1xuICAgICAgICAgIGluc3RhbmNlOiBlZGl0b3IsXG4gICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH0sXG4gICAgICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZSh7fSlcbiAgICAgIC8vIFByZXZlbnQgdGhlIHByb3RvdHlwZSBwb2xsdXRpb24uXG4gICAgKTtcbiAgICBjb25zdCBvbkVkaXRvclN0YXR1c0NoYW5nZSA9ICgpID0+IHtcbiAgICAgIG9uQ2hhbmdlSW5pdGlhbGl6ZWRFZGl0b3JzU2FmZShcbiAgICAgICAgZ2V0SW5pdGlhbGl6ZWRDb250ZXh0RWRpdG9ycygpLFxuICAgICAgICB3YXRjaGRvZ1xuICAgICAgKTtcbiAgICB9O1xuICAgIGNvbnN0IHRyYWNrRWRpdG9yTGlmZWN5Y2xlID0gKGVkaXRvcikgPT4ge1xuICAgICAgZWRpdG9yLm9uY2UoXCJyZWFkeVwiLCBvbkVkaXRvclN0YXR1c0NoYW5nZSwgeyBwcmlvcml0eTogXCJsb3dlc3RcIiB9KTtcbiAgICAgIGVkaXRvci5vbmNlKFwiZGVzdHJveVwiLCBvbkVkaXRvclN0YXR1c0NoYW5nZSwgeyBwcmlvcml0eTogXCJsb3dlc3RcIiB9KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uQWRkRWRpdG9yVG9Db2xsZWN0aW9uID0gKF8sIGVkaXRvcikgPT4ge1xuICAgICAgdHJhY2tFZGl0b3JMaWZlY3ljbGUoZWRpdG9yKTtcbiAgICB9O1xuICAgIGVkaXRvcnMuZm9yRWFjaCh0cmFja0VkaXRvckxpZmVjeWNsZSk7XG4gICAgZWRpdG9ycy5vbihcImFkZFwiLCBvbkFkZEVkaXRvclRvQ29sbGVjdGlvbik7XG4gICAgaWYgKEFycmF5LmZyb20oZWRpdG9ycykuc29tZSgoZWRpdG9yKSA9PiBlZGl0b3Iuc3RhdGUgPT09IFwicmVhZHlcIikpIHtcbiAgICAgIG9uRWRpdG9yU3RhdHVzQ2hhbmdlKCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBlZGl0b3JzLm9mZihcImFkZFwiLCBvbkFkZEVkaXRvclRvQ29sbGVjdGlvbik7XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRDb250ZXh0V2F0Y2hkb2ddKTtcbn07XG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmNvbnN0IENvbnRleHRXYXRjaGRvZ0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgQ0tFZGl0b3JDb250ZXh0ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBpZCxcbiAgICBjb250ZXh0LFxuICAgIHdhdGNoZG9nQ29uZmlnLFxuICAgIGNoaWxkcmVuLFxuICAgIGNvbmZpZyxcbiAgICBvblJlYWR5LFxuICAgIGNvbnRleHRXYXRjaGRvZzogQ29udGV4dFdhdGNoZG9nQ29uc3RydWN0b3IsXG4gICAgaXNMYXlvdXRSZWFkeSA9IHRydWUsXG4gICAgb25DaGFuZ2VJbml0aWFsaXplZEVkaXRvcnMsXG4gICAgb25FcnJvciA9IChlcnJvciwgZGV0YWlscykgPT4gY29uc29sZS5lcnJvcihlcnJvciwgZGV0YWlscylcbiAgfSA9IHByb3BzO1xuICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VJc01vdW50ZWRSZWYoKTtcbiAgY29uc3QgcHJldldhdGNoZG9nSW5pdGlhbGl6YXRpb25JRFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRDb250ZXh0V2F0Y2hkb2csIHNldEN1cnJlbnRDb250ZXh0V2F0Y2hkb2ddID0gdXNlU3RhdGUoe1xuICAgIHN0YXR1czogXCJpbml0aWFsaXppbmdcIlxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNMYXlvdXRSZWFkeSkge1xuICAgICAgaW5pdGlhbGl6ZUNvbnRleHRXYXRjaGRvZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRDdXJyZW50Q29udGV4dFdhdGNoZG9nKHtcbiAgICAgICAgc3RhdHVzOiBcImluaXRpYWxpemluZ1wiXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtpZCwgaXNMYXlvdXRSZWFkeV0pO1xuICB1c2VFZmZlY3QoKCkgPT4gKCkgPT4ge1xuICAgIGlmIChjdXJyZW50Q29udGV4dFdhdGNoZG9nLnN0YXR1cyA9PT0gXCJpbml0aWFsaXplZFwiKSB7XG4gICAgICBjdXJyZW50Q29udGV4dFdhdGNoZG9nLndhdGNoZG9nLmRlc3Ryb3koKTtcbiAgICB9XG4gIH0sIFtjdXJyZW50Q29udGV4dFdhdGNoZG9nXSk7XG4gIHVzZUluaXRpYWxpemVkQ0tFZGl0b3JzTWFwKHtcbiAgICBjdXJyZW50Q29udGV4dFdhdGNoZG9nLFxuICAgIG9uQ2hhbmdlSW5pdGlhbGl6ZWRFZGl0b3JzXG4gIH0pO1xuICBmdW5jdGlvbiByZWdlbmVyYXRlSW5pdGlhbGl6YXRpb25JRCgpIHtcbiAgICBwcmV2V2F0Y2hkb2dJbml0aWFsaXphdGlvbklEUmVmLmN1cnJlbnQgPSB1aWQoKTtcbiAgICByZXR1cm4gcHJldldhdGNoZG9nSW5pdGlhbGl6YXRpb25JRFJlZi5jdXJyZW50O1xuICB9XG4gIGZ1bmN0aW9uIGNhblVwZGF0ZVN0YXRlKGluaXRpYWxpemF0aW9uSUQpIHtcbiAgICByZXR1cm4gcHJldldhdGNoZG9nSW5pdGlhbGl6YXRpb25JRFJlZi5jdXJyZW50ID09PSBpbml0aWFsaXphdGlvbklEICYmIGlzTW91bnRlZFJlZi5jdXJyZW50O1xuICB9XG4gIGZ1bmN0aW9uIGluaXRpYWxpemVDb250ZXh0V2F0Y2hkb2coKSB7XG4gICAgY29uc3Qgd2F0Y2hkb2dJbml0aWFsaXphdGlvbklEID0gcmVnZW5lcmF0ZUluaXRpYWxpemF0aW9uSUQoKTtcbiAgICBjb25zdCBjb250ZXh0V2F0Y2hkb2cgPSBuZXcgQ29udGV4dFdhdGNoZG9nQ29uc3RydWN0b3IoY29udGV4dCwgd2F0Y2hkb2dDb25maWcpO1xuICAgIGNvbnRleHRXYXRjaGRvZy5vbihcImVycm9yXCIsIChfLCBlcnJvckV2ZW50KSA9PiB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtLSBAcHJlc2VydmUgKi9cbiAgICAgIGlmIChjYW5VcGRhdGVTdGF0ZSh3YXRjaGRvZ0luaXRpYWxpemF0aW9uSUQpKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyb3JFdmVudC5lcnJvciwge1xuICAgICAgICAgIHBoYXNlOiBcInJ1bnRpbWVcIixcbiAgICAgICAgICB3aWxsQ29udGV4dFJlc3RhcnQ6IGVycm9yRXZlbnQuY2F1c2VzUmVzdGFydFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb250ZXh0V2F0Y2hkb2cub24oXCJzdGF0ZUNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBpZiAob25SZWFkeSAmJiBjb250ZXh0V2F0Y2hkb2cuc3RhdGUgPT09IFwicmVhZHlcIiAmJiBjYW5VcGRhdGVTdGF0ZSh3YXRjaGRvZ0luaXRpYWxpemF0aW9uSUQpKSB7XG4gICAgICAgIG9uUmVhZHkoXG4gICAgICAgICAgY29udGV4dFdhdGNoZG9nLmNvbnRleHQsXG4gICAgICAgICAgY29udGV4dFdhdGNoZG9nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29udGV4dFdhdGNoZG9nLmNyZWF0ZShjb25maWcpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKGNhblVwZGF0ZVN0YXRlKHdhdGNoZG9nSW5pdGlhbGl6YXRpb25JRCkpIHtcbiAgICAgICAgc2V0Q3VycmVudENvbnRleHRXYXRjaGRvZyh7XG4gICAgICAgICAgc3RhdHVzOiBcImluaXRpYWxpemVkXCIsXG4gICAgICAgICAgd2F0Y2hkb2c6IGNvbnRleHRXYXRjaGRvZ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHRXYXRjaGRvZy5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBpZiAoY2FuVXBkYXRlU3RhdGUod2F0Y2hkb2dJbml0aWFsaXphdGlvbklEKSkge1xuICAgICAgICBvbkVycm9yKGVycm9yLCB7XG4gICAgICAgICAgcGhhc2U6IFwiaW5pdGlhbGl6YXRpb25cIixcbiAgICAgICAgICB3aWxsQ29udGV4dFJlc3RhcnQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBzZXRDdXJyZW50Q29udGV4dFdhdGNoZG9nKHtcbiAgICAgICAgICBzdGF0dXM6IFwiZXJyb3JcIixcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29udGV4dFdhdGNoZG9nO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0V2F0Y2hkb2dDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjdXJyZW50Q29udGV4dFdhdGNoZG9nIH0sIGNoaWxkcmVuKTtcbn07XG5jb25zdCBpc0NvbnRleHRXYXRjaGRvZ1ZhbHVlID0gKG9iaikgPT4gISFvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBcInN0YXR1c1wiIGluIG9iaiAmJiBbXCJpbml0aWFsaXppbmdcIiwgXCJpbml0aWFsaXplZFwiLCBcImVycm9yXCJdLmluY2x1ZGVzKG9iai5zdGF0dXMpO1xuY29uc3QgaXNDb250ZXh0V2F0Y2hkb2dWYWx1ZVdpdGhTdGF0dXMgPSAoc3RhdHVzKSA9PiAob2JqKSA9PiBpc0NvbnRleHRXYXRjaGRvZ1ZhbHVlKG9iaikgJiYgb2JqLnN0YXR1cyA9PT0gc3RhdHVzO1xuY29uc3QgaXNDb250ZXh0V2F0Y2hkb2dJbml0aWFsaXppbmcgPSBpc0NvbnRleHRXYXRjaGRvZ1ZhbHVlV2l0aFN0YXR1cyhcImluaXRpYWxpemluZ1wiKTtcbmNvbnN0IGlzQ29udGV4dFdhdGNoZG9nUmVhZHlUb1VzZSA9IChvYmopID0+IGlzQ29udGV4dFdhdGNoZG9nVmFsdWVXaXRoU3RhdHVzKFwiaW5pdGlhbGl6ZWRcIikob2JqKSAmJiBvYmoud2F0Y2hkb2cuc3RhdGUgPT09IFwicmVhZHlcIjtcbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuY29uc3QgUmVhY3RJbnRlZ3JhdGlvblVzYWdlRGF0YVBsdWdpbiA9IGNyZWF0ZUludGVncmF0aW9uVXNhZ2VEYXRhUGx1Z2luKFxuICBcInJlYWN0XCIsXG4gIHtcbiAgICB2ZXJzaW9uOiBcIjExLjAuMFwiLFxuICAgIGZyYW1ld29ya1ZlcnNpb246IFJlYWN0LnZlcnNpb25cbiAgfVxuKTtcbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwZW5kQWxsSW50ZWdyYXRpb25QbHVnaW5zVG9Db25maWcoZWRpdG9yQ29uZmlnKSB7XG4gIGlmIChpc0NLRWRpdG9yRnJlZUxpY2Vuc2UoZWRpdG9yQ29uZmlnLmxpY2Vuc2VLZXkpKSB7XG4gICAgcmV0dXJuIGVkaXRvckNvbmZpZztcbiAgfVxuICByZXR1cm4gYXBwZW5kRXh0cmFQbHVnaW5zVG9FZGl0b3JDb25maWcoZWRpdG9yQ29uZmlnLCBbXG4gICAgLyoqXG4gICAgICogVGhpcyBwYXJ0IG9mIHRoZSBjb2RlIGlzIG5vdCBleGVjdXRlZCBpbiBvcGVuLXNvdXJjZSBpbXBsZW1lbnRhdGlvbnMgdXNpbmcgYSBHUEwga2V5LlxuICAgICAqIEl0IG9ubHkgcnVucyB3aGVuIGEgc3BlY2lmaWMgbGljZW5zZSBrZXkgaXMgcHJvdmlkZWQuIElmIHlvdSBhcmUgdW5jZXJ0YWluIHdoZXRoZXJcbiAgICAgKiB0aGlzIGFwcGxpZXMgdG8geW91ciBpbnN0YWxsYXRpb24sIHBsZWFzZSBjb250YWN0IG91ciBzdXBwb3J0IHRlYW0uXG4gICAgICovXG4gICAgUmVhY3RJbnRlZ3JhdGlvblVzYWdlRGF0YVBsdWdpblxuICBdKTtcbn1cbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuY29uc3QgUkVBQ1RfSU5URUdSQVRJT05fUkVBRF9PTkxZX0xPQ0tfSUQkMSA9IFwiTG9jayBmcm9tIFJlYWN0IGludGVncmF0aW9uIChAY2tlZGl0b3IvY2tlZGl0b3I1LXJlYWN0KVwiO1xuY2xhc3MgQ0tFZGl0b3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICAvKipcbiAgICAgKiBBZnRlciBtb3VudGluZyB0aGUgZWRpdG9yLCB0aGUgdmFyaWFibGUgd2lsbCBjb250YWluIGEgcmVmZXJlbmNlIHRvIHRoZSBjcmVhdGVkIGVkaXRvci5cbiAgICAgKiBAc2VlOiBodHRwczovL2NrZWRpdG9yLmNvbS9kb2NzL2NrZWRpdG9yNS9sYXRlc3QvYXBpL21vZHVsZV9jb3JlX2VkaXRvcl9lZGl0b3ItRWRpdG9yLmh0bWxcbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZG9tQ29udGFpbmVyXCIsIFJlYWN0LmNyZWF0ZVJlZigpKTtcbiAgICAvKipcbiAgICAgKiBVbmxvY2tzIGVsZW1lbnQgaW4gZWRpdG9yIHNlbWFwaG9yZSBhZnRlciBkZXN0cm95IGVkaXRvciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZWRpdG9yU2VtYXBob3JlXCIsIG51bGwpO1xuICAgIHRoaXMuX2NoZWNrVmVyc2lvbigpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIENLRWRpdG9yIHZlcnNpb24gdXNlZCBpbiB0aGUgYXBwbGljYXRpb24gaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBfY2hlY2tWZXJzaW9uKCkge1xuICAgIGNvbnN0IHsgQ0tFRElUT1JfVkVSU0lPTiB9ID0gd2luZG93O1xuICAgIGlmICghQ0tFRElUT1JfVkVSU0lPTikge1xuICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignQ2Fubm90IGZpbmQgdGhlIFwiQ0tFRElUT1JfVkVSU0lPTlwiIGluIHRoZSBcIndpbmRvd1wiIHNjb3BlLicpO1xuICAgIH1cbiAgICBjb25zdCBbbWFqb3JdID0gQ0tFRElUT1JfVkVSU0lPTi5zcGxpdChcIi5cIikubWFwKE51bWJlcik7XG4gICAgaWYgKG1ham9yID49IDQyIHx8IENLRURJVE9SX1ZFUlNJT04uc3RhcnRzV2l0aChcIjAuMC4wXCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUud2FybihcIlRoZSA8Q0tFZGl0b3I+IGNvbXBvbmVudCByZXF1aXJlcyB1c2luZyBDS0VkaXRvciA1IGluIHZlcnNpb24gNDIrIG9yIG5pZ2h0bHkgYnVpbGQuXCIpO1xuICB9XG4gIGdldCBfc2VtYXBob3JlVmFsdWUoKSB7XG4gICAgY29uc3QgeyBlZGl0b3JTZW1hcGhvcmUgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGVkaXRvclNlbWFwaG9yZSA/IGVkaXRvclNlbWFwaG9yZS52YWx1ZSA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEFuIHdhdGNoZG9nIGluc3RhbmNlLlxuICAgKi9cbiAgZ2V0IHdhdGNoZG9nKCkge1xuICAgIGNvbnN0IHsgX3NlbWFwaG9yZVZhbHVlIH0gPSB0aGlzO1xuICAgIHJldHVybiBfc2VtYXBob3JlVmFsdWUgPyBfc2VtYXBob3JlVmFsdWUud2F0Y2hkb2cgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBBbiBlZGl0b3IgaW5zdGFuY2UuXG4gICAqL1xuICBnZXQgZWRpdG9yKCkge1xuICAgIGNvbnN0IHsgX3NlbWFwaG9yZVZhbHVlIH0gPSB0aGlzO1xuICAgIHJldHVybiBfc2VtYXBob3JlVmFsdWUgPyBfc2VtYXBob3JlVmFsdWUuaW5zdGFuY2UgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgQ0tFZGl0b3IgY29tcG9uZW50IHNob3VsZCBub3QgYmUgdXBkYXRlZCBieSBSZWFjdCBpdHNlbGYuXG4gICAqIEhvd2V2ZXIsIGlmIHRoZSBjb21wb25lbnQgaWRlbnRpZmllciBjaGFuZ2VzLCB0aGUgd2hvbGUgc3RydWN0dXJlIHNob3VsZCBiZSBjcmVhdGVkIG9uY2UgYWdhaW4uXG4gICAqL1xuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgY29uc3QgeyBwcm9wcywgZWRpdG9yU2VtYXBob3JlIH0gPSB0aGlzO1xuICAgIGlmIChuZXh0UHJvcHMuaWQgIT09IHByb3BzLmlkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5leHRQcm9wcy5kaXNhYmxlV2F0Y2hkb2cgIT09IHByb3BzLmRpc2FibGVXYXRjaGRvZykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChlZGl0b3JTZW1hcGhvcmUpIHtcbiAgICAgIGVkaXRvclNlbWFwaG9yZS5ydW5BZnRlck1vdW50KCh7IGluc3RhbmNlIH0pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZFVwZGF0ZUVkaXRvckRhdGEocHJvcHMsIG5leHRQcm9wcywgaW5zdGFuY2UpKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZGF0YS5zZXQobmV4dFByb3BzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChcImRpc2FibGVkXCIgaW4gbmV4dFByb3BzKSB7XG4gICAgICAgIGVkaXRvclNlbWFwaG9yZS5ydW5BZnRlck1vdW50KCh7IGluc3RhbmNlIH0pID0+IHtcbiAgICAgICAgICBpZiAobmV4dFByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5lbmFibGVSZWFkT25seU1vZGUoUkVBQ1RfSU5URUdSQVRJT05fUkVBRF9PTkxZX0xPQ0tfSUQkMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmRpc2FibGVSZWFkT25seU1vZGUoUkVBQ1RfSU5URUdSQVRJT05fUkVBRF9PTkxZX0xPQ0tfSUQkMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBlZGl0b3Igd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAoIWlzQ29udGV4dFdhdGNoZG9nSW5pdGlhbGl6aW5nKHRoaXMuY29udGV4dCkpIHtcbiAgICAgIHRoaXMuX2luaXRMaWZlQ3ljbGVTZW1hcGhvcmUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlLXJlbmRlciB0aGUgZW50aXJlIGNvbXBvbmVudCBvbmNlIGFnYWluLiBUaGUgb2xkIGVkaXRvciB3aWxsIGJlIGRlc3Ryb3llZCBhbmQgdGhlIG5ldyBvbmUgd2lsbCBiZSBjcmVhdGVkLlxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGlmICghaXNDb250ZXh0V2F0Y2hkb2dJbml0aWFsaXppbmcodGhpcy5jb250ZXh0KSkge1xuICAgICAgdGhpcy5faW5pdExpZmVDeWNsZVNlbWFwaG9yZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVzdHJveSB0aGUgZWRpdG9yIGJlZm9yZSB1bm1vdW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLl91bmxvY2tMaWZlQ3ljbGVTZW1hcGhvcmUoKTtcbiAgfVxuICAvKipcbiAgICogQXN5bmMgZGVzdHJveSBhdHRhY2hlZCBlZGl0b3IgYW5kIHVubG9jayBlbGVtZW50IHNlbWFwaG9yZS5cbiAgICovXG4gIF91bmxvY2tMaWZlQ3ljbGVTZW1hcGhvcmUoKSB7XG4gICAgaWYgKHRoaXMuZWRpdG9yU2VtYXBob3JlKSB7XG4gICAgICB0aGlzLmVkaXRvclNlbWFwaG9yZS5yZWxlYXNlKCk7XG4gICAgICB0aGlzLmVkaXRvclNlbWFwaG9yZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVbmxvY2tzIHByZXZpb3VzIGVkaXRvciBzZW1hcGhvcmUgYW5kIGNyZWF0ZXMgbmV3IG9uZS4uXG4gICAqL1xuICBfaW5pdExpZmVDeWNsZVNlbWFwaG9yZSgpIHtcbiAgICB0aGlzLl91bmxvY2tMaWZlQ3ljbGVTZW1hcGhvcmUoKTtcbiAgICB0aGlzLmVkaXRvclNlbWFwaG9yZSA9IG5ldyBMaWZlQ3ljbGVFbGVtZW50U2VtYXBob3JlKHRoaXMuZG9tQ29udGFpbmVyLmN1cnJlbnQsIHtcbiAgICAgIGlzVmFsdWVWYWxpZDogKHZhbHVlKSA9PiB2YWx1ZSAmJiAhIXZhbHVlLmluc3RhbmNlLFxuICAgICAgbW91bnQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5faW5pdGlhbGl6ZUVkaXRvcigpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMucHJvcHMpLm9uRXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBlcnJvciwgeyBwaGFzZTogXCJpbml0aWFsaXphdGlvblwiLCB3aWxsRWRpdG9yUmVzdGFydDogZmFsc2UgfSk7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhZnRlck1vdW50OiAoeyBtb3VudFJlc3VsdCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25SZWFkeSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKG9uUmVhZHkgJiYgdGhpcy5kb21Db250YWluZXIuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIG9uUmVhZHkobW91bnRSZXN1bHQuaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5tb3VudDogYXN5bmMgKHsgZWxlbWVudCwgbW91bnRSZXN1bHQgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IG9uQWZ0ZXJEZXN0cm95IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX2Rlc3Ryb3lFZGl0b3IobW91bnRSZXN1bHQpO1xuICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAob25BZnRlckRlc3Ryb3kpIHtcbiAgICAgICAgICAgIG9uQWZ0ZXJEZXN0cm95KG1vdW50UmVzdWx0Lmluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVyIGEgPGRpdj4gZWxlbWVudCB3aGljaCB3aWxsIGJlIHJlcGxhY2VkIGJ5IENLRWRpdG9yLlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5kb21Db250YWluZXIgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBlZGl0b3IgYnkgY3JlYXRpbmcgYSBwcm9wZXIgd2F0Y2hkb2cgYW5kIGluaXRpYWxpemluZyBpdCB3aXRoIHRoZSBlZGl0b3IncyBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgYXN5bmMgX2luaXRpYWxpemVFZGl0b3IoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZVdhdGNoZG9nKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGF3YWl0IHRoaXMuX2NyZWF0ZUVkaXRvcih0aGlzLmRvbUNvbnRhaW5lci5jdXJyZW50LCB0aGlzLl9nZXRDb25maWcoKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgd2F0Y2hkb2c6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHdhdGNoZG9nID0gKCgpID0+IHtcbiAgICAgIGlmIChpc0NvbnRleHRXYXRjaGRvZ1JlYWR5VG9Vc2UodGhpcy5jb250ZXh0KSkge1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvcldhdGNoZG9nQWRhcHRlcih0aGlzLmNvbnRleHQud2F0Y2hkb2cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyB0aGlzLnByb3BzLmVkaXRvci5FZGl0b3JXYXRjaGRvZyh0aGlzLnByb3BzLmVkaXRvciwgdGhpcy5wcm9wcy53YXRjaGRvZ0NvbmZpZyk7XG4gICAgfSkoKTtcbiAgICBjb25zdCB0b3RhbFJlc3RhcnRzUmVmID0ge1xuICAgICAgY3VycmVudDogMFxuICAgIH07XG4gICAgd2F0Y2hkb2cuc2V0Q3JlYXRvcihhc3luYyAoZWwsIGNvbmZpZykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgeyBlZGl0b3JTZW1hcGhvcmUgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7IG9uQWZ0ZXJEZXN0cm95IH0gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKHRvdGFsUmVzdGFydHNSZWYuY3VycmVudCA+IDAgJiYgb25BZnRlckRlc3Ryb3kgJiYgKChfYSA9IGVkaXRvclNlbWFwaG9yZSA9PSBudWxsID8gdm9pZCAwIDogZWRpdG9yU2VtYXBob3JlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaW5zdGFuY2UpKSB7XG4gICAgICAgIG9uQWZ0ZXJEZXN0cm95KGVkaXRvclNlbWFwaG9yZS52YWx1ZS5pbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGF3YWl0IHRoaXMuX2NyZWF0ZUVkaXRvcihlbCwgY29uZmlnKTtcbiAgICAgIGlmIChlZGl0b3JTZW1hcGhvcmUgJiYgdG90YWxSZXN0YXJ0c1JlZi5jdXJyZW50ID4gMCkge1xuICAgICAgICBlZGl0b3JTZW1hcGhvcmUudW5zYWZlU2V0VmFsdWUoe1xuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIHdhdGNoZG9nXG4gICAgICAgIH0pO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblJlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uUmVhZHkod2F0Y2hkb2cuZWRpdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdG90YWxSZXN0YXJ0c1JlZi5jdXJyZW50Kys7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSk7XG4gICAgd2F0Y2hkb2cub24oXCJlcnJvclwiLCAoXywgeyBlcnJvciwgY2F1c2VzUmVzdGFydCB9KSA9PiB7XG4gICAgICBjb25zdCBvbkVycm9yID0gdGhpcy5wcm9wcy5vbkVycm9yIHx8IGNvbnNvbGUuZXJyb3I7XG4gICAgICBvbkVycm9yKGVycm9yLCB7IHBoYXNlOiBcInJ1bnRpbWVcIiwgd2lsbEVkaXRvclJlc3RhcnQ6IGNhdXNlc1Jlc3RhcnQgfSk7XG4gICAgfSk7XG4gICAgYXdhaXQgd2F0Y2hkb2cuY3JlYXRlKHRoaXMuZG9tQ29udGFpbmVyLmN1cnJlbnQsIHRoaXMuX2dldENvbmZpZygpKTtcbiAgICByZXR1cm4ge1xuICAgICAgd2F0Y2hkb2csXG4gICAgICBpbnN0YW5jZTogd2F0Y2hkb2cuZWRpdG9yXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBlZGl0b3IgZnJvbSB0aGUgZWxlbWVudCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIHNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0gY29uZmlnIENLRWRpdG9yIDUgZWRpdG9yIGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBfY3JlYXRlRWRpdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIGNvbnN0IHsgY29udGV4dEl0ZW1NZXRhZGF0YSB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoY29udGV4dEl0ZW1NZXRhZGF0YSkge1xuICAgICAgY29uZmlnID0gd2l0aENLRWRpdG9yUmVhY3RDb250ZXh0TWV0YWRhdGEoY29udGV4dEl0ZW1NZXRhZGF0YSwgY29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuZWRpdG9yLmNyZWF0ZShcbiAgICAgIGVsZW1lbnQsXG4gICAgICBhcHBlbmRBbGxJbnRlZ3JhdGlvblBsdWdpbnNUb0NvbmZpZyhjb25maWcpXG4gICAgKS50aGVuKChlZGl0b3IpID0+IHtcbiAgICAgIGlmIChcImRpc2FibGVkXCIgaW4gdGhpcy5wcm9wcykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtLSBAcHJlc2VydmUgKi9cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgICBlZGl0b3IuZW5hYmxlUmVhZE9ubHlNb2RlKFJFQUNUX0lOVEVHUkFUSU9OX1JFQURfT05MWV9MT0NLX0lEJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbERvY3VtZW50ID0gZWRpdG9yLm1vZGVsLmRvY3VtZW50O1xuICAgICAgY29uc3Qgdmlld0RvY3VtZW50ID0gZWRpdG9yLmVkaXRpbmcudmlldy5kb2N1bWVudDtcbiAgICAgIG1vZGVsRG9jdW1lbnQub24oXCJjaGFuZ2U6ZGF0YVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLS0gQHByZXNlcnZlICovXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ2hhbmdlKSB7XG4gICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShldmVudCwgZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2aWV3RG9jdW1lbnQub24oXCJmb2N1c1wiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLS0gQHByZXNlcnZlICovXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uRm9jdXMpIHtcbiAgICAgICAgICB0aGlzLnByb3BzLm9uRm9jdXMoZXZlbnQsIGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmlld0RvY3VtZW50Lm9uKFwiYmx1clwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLS0gQHByZXNlcnZlICovXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uQmx1cikge1xuICAgICAgICAgIHRoaXMucHJvcHMub25CbHVyKGV2ZW50LCBlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBlZGl0b3IgYnkgZGVzdHJveWluZyB0aGUgd2F0Y2hkb2cuXG4gICAqL1xuICBhc3luYyBfZGVzdHJveUVkaXRvcihpbml0aWFsaXplUmVzdWx0KSB7XG4gICAgY29uc3QgeyB3YXRjaGRvZywgaW5zdGFuY2UgfSA9IGluaXRpYWxpemVSZXN1bHQ7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0tIEBwcmVzZXJ2ZSAqL1xuICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHdhdGNoZG9nKSB7XG4gICAgICAgICAgICBhd2FpdCB3YXRjaGRvZy5kZXN0cm95KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGF3YWl0IGluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIGVkaXRvciBzaG91bGQgYmUgdXBkYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHByZXZQcm9wcyBQcmV2aW91cyByZWFjdCdzIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSBuZXh0UHJvcHMgUmVhY3QncyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gZWRpdG9yIEN1cnJlbnQgZWRpdG9yIGluc3RhbmNlLlxuICAgKi9cbiAgX3Nob3VsZFVwZGF0ZUVkaXRvckRhdGEocHJldlByb3BzLCBuZXh0UHJvcHMsIGVkaXRvcikge1xuICAgIGlmIChwcmV2UHJvcHMuZGF0YSA9PT0gbmV4dFByb3BzLmRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGVkaXRvci5kYXRhLmdldCgpID09PSBuZXh0UHJvcHMuZGF0YSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWRpdG9yIGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBfZ2V0Q29uZmlnKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMucHJvcHMuY29uZmlnIHx8IHt9O1xuICAgIGlmICh0aGlzLnByb3BzLmRhdGEgJiYgY29uZmlnLmluaXRpYWxEYXRhKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiRWRpdG9yIGRhdGEgc2hvdWxkIGJlIHByb3ZpZGVkIGVpdGhlciB1c2luZyBgY29uZmlnLmluaXRpYWxEYXRhYCBvciBgY29udGVudGAgcHJvcGVydHkuIFRoZSBjb25maWcgdmFsdWUgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBjb250ZW50YCBwcm9wZXJ0eSBhbmQgd2lsbCBiZSB1c2VkIHdoZW4gYm90aCBhcmUgc3BlY2lmaWVkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgaW5pdGlhbERhdGE6IGNvbmZpZy5pbml0aWFsRGF0YSB8fCB0aGlzLnByb3BzLmRhdGEgfHwgXCJcIlxuICAgIH07XG4gIH1cbn1cbl9fcHVibGljRmllbGQoQ0tFZGl0b3IsIFwiY29udGV4dFR5cGVcIiwgQ29udGV4dFdhdGNoZG9nQ29udGV4dCk7XG5jbGFzcyBFZGl0b3JXYXRjaGRvZ0FkYXB0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIGNvbnRleHRXYXRjaGRvZyBUaGUgY29udGV4dCB3YXRjaGRvZyBpbnN0YW5jZSB0aGF0IHdpbGwgYmUgd3JhcHBlZCBpbnRvIGVkaXRvciB3YXRjaGRvZyBBUEkuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0V2F0Y2hkb2cpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgY29udGV4dCB3YXRjaGRvZyBpbnN0YW5jZSB0aGF0IHdpbGwgYmUgd3JhcHBlZCBpbnRvIGVkaXRvciB3YXRjaGRvZyBBUEkuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9jb250ZXh0V2F0Y2hkb2dcIik7XG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgaWQgZm9yIHRoZSBhZGFwdGVyIHRvIGRpc3Rpbmd1aXNoIGVkaXRvciBpdGVtcyB3aGVuIHVzaW5nIHRoZSBjb250ZXh0IHdhdGNoZG9nIEFQSS5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2lkXCIpO1xuICAgIC8qKlxuICAgICAqIEEgd2F0Y2hkb2cncyBlZGl0b3IgY3JlYXRvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2NyZWF0b3JcIik7XG4gICAgdGhpcy5fY29udGV4dFdhdGNoZG9nID0gY29udGV4dFdhdGNoZG9nO1xuICAgIHRoaXMuX2lkID0gdWlkKCk7XG4gIH1cbiAgLyoqXG4gICAqICBAcGFyYW0gY3JlYXRvciBBIHdhdGNoZG9nJ3MgZWRpdG9yIGNyZWF0b3IgZnVuY3Rpb24uXG4gICAqL1xuICBzZXRDcmVhdG9yKGNyZWF0b3IpIHtcbiAgICB0aGlzLl9jcmVhdG9yID0gY3JlYXRvcjtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBlZGl0b3IgY29uZmlndXJhdGlvbiB0byB0aGUgY29udGV4dCB3YXRjaGRvZyByZWdpc3RyeS4gQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBpdC5cbiAgICpcbiAgICogQHBhcmFtIHNvdXJjZUVsZW1lbnRPckRhdGEgQSBzb3VyY2UgZWxlbWVudCBvciBkYXRhIGZvciB0aGUgbmV3IGVkaXRvci5cbiAgICogQHBhcmFtIGNvbmZpZyBDS0VkaXRvciA1IGVkaXRvciBjb25maWcuXG4gICAqL1xuICBjcmVhdGUoc291cmNlRWxlbWVudE9yRGF0YSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHRXYXRjaGRvZy5hZGQoe1xuICAgICAgc291cmNlRWxlbWVudE9yRGF0YSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIGNyZWF0b3I6IHRoaXMuX2NyZWF0b3IsXG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICB0eXBlOiBcImVkaXRvclwiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsaXN0ZW5lciB0aGF0IGlzIGF0dGFjaGVkIHRvIGNvbnRleHQgd2F0Y2hkb2cncyBpdGVtIGFuZCBydW4gd2hlbiB0aGUgY29udGV4dCB3YXRjaGRvZyBmaXJlcy5cbiAgICogQ3VycmVudGx5IHdvcmtzIG9ubHkgZm9yIHRoZSBgZXJyb3JgIGV2ZW50LlxuICAgKi9cbiAgb24oXywgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9jb250ZXh0V2F0Y2hkb2cub24oXCJpdGVtRXJyb3JcIiwgKF8yLCB7IGl0ZW1JZCwgZXJyb3IgfSkgPT4ge1xuICAgICAgaWYgKGl0ZW1JZCA9PT0gdGhpcy5faWQpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBlcnJvciwgY2F1c2VzUmVzdGFydDogdm9pZCAwIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRleHRXYXRjaGRvZy5zdGF0ZSA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGV4dFdhdGNoZG9nLnJlbW92ZSh0aGlzLl9pZCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICAvKipcbiAgICogQW4gZWRpdG9yIGluc3RhbmNlLlxuICAgKi9cbiAgZ2V0IGVkaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dFdhdGNoZG9nLmdldEl0ZW0odGhpcy5faWQpO1xuICB9XG59XG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmNvbnN0IHVzZUxpZmVDeWNsZVNlbWFwaG9yZVN5bmNSZWYgPSAoKSA9PiB7XG4gIGNvbnN0IHNlbWFwaG9yZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW3JldmlzaW9uLCBzZXRSZXZpc2lvbl0gPSB1c2VTdGF0ZSgoKSA9PiBEYXRlLm5vdygpKTtcbiAgY29uc3QgcmVmcmVzaCA9ICgpID0+IHtcbiAgICBzZXRSZXZpc2lvbihEYXRlLm5vdygpKTtcbiAgfTtcbiAgY29uc3QgcmVsZWFzZSA9IChyZXJlbmRlciA9IHRydWUpID0+IHtcbiAgICBpZiAoc2VtYXBob3JlUmVmLmN1cnJlbnQpIHtcbiAgICAgIHNlbWFwaG9yZVJlZi5jdXJyZW50LnJlbGVhc2UoKTtcbiAgICAgIHNlbWFwaG9yZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJlcmVuZGVyKSB7XG4gICAgICBzZXRSZXZpc2lvbihEYXRlLm5vdygpKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVuc2FmZVNldFZhbHVlID0gKHZhbHVlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHNlbWFwaG9yZVJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EudW5zYWZlU2V0VmFsdWUodmFsdWUpO1xuICAgIHJlZnJlc2goKTtcbiAgfTtcbiAgY29uc3QgcnVuQWZ0ZXJNb3VudCA9IChjYWxsYmFjaykgPT4ge1xuICAgIGlmIChzZW1hcGhvcmVSZWYuY3VycmVudCkge1xuICAgICAgc2VtYXBob3JlUmVmLmN1cnJlbnQucnVuQWZ0ZXJNb3VudChjYWxsYmFjayk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZXBsYWNlID0gKG5ld1NlbWFwaG9yZSkgPT4ge1xuICAgIHJlbGVhc2UoZmFsc2UpO1xuICAgIHNlbWFwaG9yZVJlZi5jdXJyZW50ID0gbmV3U2VtYXBob3JlKCk7XG4gICAgcmVmcmVzaCgpO1xuICAgIHJ1bkFmdGVyTW91bnQocmVmcmVzaCk7XG4gIH07XG4gIGNvbnN0IGNyZWF0ZUF0dHJpYnV0ZVJlZiA9IChrZXkpID0+ICh7XG4gICAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgICBpZiAoIXNlbWFwaG9yZVJlZi5jdXJyZW50IHx8ICFzZW1hcGhvcmVSZWYuY3VycmVudC52YWx1ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZW1hcGhvcmVSZWYuY3VycmVudC52YWx1ZVtrZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgICByZXR1cm4gc2VtYXBob3JlUmVmLmN1cnJlbnQ7XG4gICAgfSxcbiAgICByZXZpc2lvbixcbiAgICBjcmVhdGVBdHRyaWJ1dGVSZWYsXG4gICAgdW5zYWZlU2V0VmFsdWUsXG4gICAgcmVsZWFzZSxcbiAgICByZXBsYWNlLFxuICAgIHJ1bkFmdGVyTW91bnRcbiAgfTtcbn07XG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmZ1bmN0aW9uIG1lcmdlUmVmcyguLi5yZWZzKSB7XG4gIHJldHVybiAodmFsdWUpID0+IHtcbiAgICByZWZzLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZWYodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuLyoqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDMtMjAyNSwgQ0tTb3VyY2UgSG9sZGluZyBzcC4geiBvLm8uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1saWNlbnNpbmctb3B0aW9uc1xuICovXG5jb25zdCB1c2VJbnN0YW50RWZmZWN0ID0gKGZuLCBkZXBzKSA9PiB7XG4gIGNvbnN0IFtwcmV2RGVwcywgc2V0RGVwc10gPSB1c2VTdGF0ZShudWxsKTtcbiAgaWYgKCFzaGFsbG93Q29tcGFyZUFycmF5cyhwcmV2RGVwcywgZGVwcykpIHtcbiAgICBmbigpO1xuICAgIHNldERlcHMoWy4uLmRlcHNdKTtcbiAgfVxufTtcbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuY29uc3QgdXNlSW5zdGFudEVkaXRvckVmZmVjdCA9IChzZW1hcGhvcmUsIGZuLCBkZXBzKSA9PiB7XG4gIHVzZUluc3RhbnRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzZW1hcGhvcmUpIHtcbiAgICAgIHNlbWFwaG9yZS5ydW5BZnRlck1vdW50KGZuKTtcbiAgICB9XG4gIH0sIFtzZW1hcGhvcmUsIC4uLmRlcHNdKTtcbn07XG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmNvbnN0IFJFQUNUX0lOVEVHUkFUSU9OX1JFQURfT05MWV9MT0NLX0lEID0gXCJMb2NrIGZyb20gUmVhY3QgaW50ZWdyYXRpb24gKEBja2VkaXRvci9ja2VkaXRvcjUtcmVhY3QpXCI7XG5jb25zdCB1c2VNdWx0aVJvb3RFZGl0b3IgPSAocHJvcHMpID0+IHtcbiAgY29uc3Qgc2VtYXBob3JlRWxlbWVudFJlZiA9IHVzZVJlZihwcm9wcy5zZW1hcGhvcmVFbGVtZW50IHx8IG51bGwpO1xuICBjb25zdCBzZW1hcGhvcmUgPSB1c2VMaWZlQ3ljbGVTZW1hcGhvcmVTeW5jUmVmKCk7XG4gIGNvbnN0IGVkaXRvclJlZnMgPSB7XG4gICAgd2F0Y2hkb2c6IHNlbWFwaG9yZS5jcmVhdGVBdHRyaWJ1dGVSZWYoXCJ3YXRjaGRvZ1wiKSxcbiAgICBpbnN0YW5jZTogc2VtYXBob3JlLmNyZWF0ZUF0dHJpYnV0ZVJlZihcImluc3RhbmNlXCIpXG4gIH07XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KENvbnRleHRXYXRjaGRvZ0NvbnRleHQpO1xuICBjb25zdCBbcm9vdHMsIHNldFJvb3RzXSA9IHVzZVN0YXRlKCgpID0+IE9iamVjdC5rZXlzKHByb3BzLmRhdGEpKTtcbiAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gdXNlU3RhdGUoeyAuLi5wcm9wcy5kYXRhIH0pO1xuICBjb25zdCBbYXR0cmlidXRlcywgc2V0QXR0cmlidXRlc10gPSB1c2VTdGF0ZSh7IC4uLnByb3BzLnJvb3RzQXR0cmlidXRlcyB9KTtcbiAgY29uc3Qgc2hvdWxkVXBkYXRlRWRpdG9yID0gdXNlUmVmKHRydWUpO1xuICBjb25zdCBmb3JjZUFzc2lnbkZha2VFZGl0YWJsZUVsZW1lbnRzID0gKCkgPT4ge1xuICAgIGNvbnN0IGVkaXRvciA9IGVkaXRvclJlZnMuaW5zdGFuY2UuY3VycmVudDtcbiAgICBpZiAoIWVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsaXplRWRpdGFibGVXaXRoRmFrZUVsZW1lbnQgPSAoZWRpdGFibGUpID0+IHtcbiAgICAgIGlmIChlZGl0YWJsZS5uYW1lICYmICFlZGl0b3IuZWRpdGluZy52aWV3LmdldERvbVJvb3QoZWRpdGFibGUubmFtZSkpIHtcbiAgICAgICAgZWRpdG9yLmVkaXRpbmcudmlldy5hdHRhY2hEb21Sb290KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGVkaXRhYmxlLm5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LnZhbHVlcyhlZGl0b3IudWkudmlldy5lZGl0YWJsZXMpLmZvckVhY2goaW5pdGlhbGl6ZUVkaXRhYmxlV2l0aEZha2VFbGVtZW50KTtcbiAgfTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzZW1hcGhvcmVFbGVtZW50ID0gc2VtYXBob3JlRWxlbWVudFJlZi5jdXJyZW50O1xuICAgIGlmIChjb250ZXh0ICYmICFpc0NvbnRleHRXYXRjaGRvZ1JlYWR5VG9Vc2UoY29udGV4dCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzZW1hcGhvcmVFbGVtZW50IHx8IHByb3BzLmlzTGF5b3V0UmVhZHkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbWFwaG9yZS5yZXBsYWNlKCgpID0+IG5ldyBMaWZlQ3ljbGVFbGVtZW50U2VtYXBob3JlKHNlbWFwaG9yZUVsZW1lbnQsIHtcbiAgICAgIG1vdW50OiBfaW5pdGlhbGl6ZUVkaXRvcixcbiAgICAgIGFmdGVyTW91bnQ6ICh7IG1vdW50UmVzdWx0IH0pID0+IHtcbiAgICAgICAgY29uc3QgeyBvblJlYWR5IH0gPSBwcm9wcztcbiAgICAgICAgaWYgKG9uUmVhZHkgJiYgc2VtYXBob3JlRWxlbWVudFJlZi5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgb25SZWFkeShtb3VudFJlc3VsdC5pbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bm1vdW50OiBhc3luYyAoeyBlbGVtZW50LCBtb3VudFJlc3VsdCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25BZnRlckRlc3Ryb3kgfSA9IHByb3BzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IF9kZXN0cm95RWRpdG9yKG1vdW50UmVzdWx0KTtcbiAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKG9uQWZ0ZXJEZXN0cm95KSB7XG4gICAgICAgICAgICBvbkFmdGVyRGVzdHJveShtb3VudFJlc3VsdC5pbnN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBmb3JjZUFzc2lnbkZha2VFZGl0YWJsZUVsZW1lbnRzKCk7XG4gICAgICBzZW1hcGhvcmUucmVsZWFzZShmYWxzZSk7XG4gICAgfTtcbiAgfSwgW3Byb3BzLmlkLCBwcm9wcy5pc0xheW91dFJlYWR5LCBjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0LnN0YXR1c10pO1xuICBjb25zdCBfZ2V0Q29uZmlnID0gKCkgPT4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IHByb3BzLmNvbmZpZyB8fCB7fTtcbiAgICBpZiAocHJvcHMuZGF0YSAmJiBjb25maWcuaW5pdGlhbERhdGEpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJFZGl0b3IgZGF0YSBzaG91bGQgYmUgcHJvdmlkZWQgZWl0aGVyIHVzaW5nIGBjb25maWcuaW5pdGlhbERhdGFgIG9yIGBkYXRhYCBwcm9wZXJ0eS4gVGhlIGNvbmZpZyB2YWx1ZSB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYGRhdGFgIHByb3BlcnR5IGFuZCB3aWxsIGJlIHVzZWQgd2hlbiBib3RoIGFyZSBzcGVjaWZpZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5jb25maWcsXG4gICAgICByb290c0F0dHJpYnV0ZXM6IGF0dHJpYnV0ZXNcbiAgICB9O1xuICB9O1xuICBjb25zdCBvbkNoYW5nZURhdGEgPSB1c2VSZWZTYWZlQ2FsbGJhY2soKGVkaXRvciwgZXZlbnQpID0+IHtcbiAgICBjb25zdCBtb2RlbERvY3VtZW50ID0gZWRpdG9yLm1vZGVsLmRvY3VtZW50O1xuICAgIGlmICghcHJvcHMuZGlzYWJsZVR3b1dheURhdGFCaW5kaW5nKSB7XG4gICAgICBjb25zdCBuZXdEYXRhID0ge307XG4gICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0ge307XG4gICAgICBtb2RlbERvY3VtZW50LmRpZmZlci5nZXRDaGFuZ2VzKCkuZm9yRWFjaCgoY2hhbmdlKSA9PiB7XG4gICAgICAgIGxldCByb290O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtLSBAcHJlc2VydmUgKi9cbiAgICAgICAgaWYgKGNoYW5nZS50eXBlID09IFwiaW5zZXJ0XCIgfHwgY2hhbmdlLnR5cGUgPT0gXCJyZW1vdmVcIikge1xuICAgICAgICAgIHJvb3QgPSBjaGFuZ2UucG9zaXRpb24ucm9vdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb290ID0gY2hhbmdlLnJhbmdlLnJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyb290LmlzQXR0YWNoZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHJvb3ROYW1lIH0gPSByb290O1xuICAgICAgICBuZXdEYXRhW3Jvb3ROYW1lXSA9IGVkaXRvci5nZXREYXRhKHsgcm9vdE5hbWUgfSk7XG4gICAgICB9KTtcbiAgICAgIG1vZGVsRG9jdW1lbnQuZGlmZmVyLmdldENoYW5nZWRSb290cygpLmZvckVhY2goKGNoYW5nZWRSb290KSA9PiB7XG4gICAgICAgIGlmIChjaGFuZ2VkUm9vdC5zdGF0ZSkge1xuICAgICAgICAgIGlmIChuZXdEYXRhW2NoYW5nZWRSb290Lm5hbWVdICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdEYXRhW2NoYW5nZWRSb290Lm5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBjaGFuZ2VkUm9vdC5uYW1lO1xuICAgICAgICBuZXdBdHRyaWJ1dGVzW3Jvb3ROYW1lXSA9IGVkaXRvci5nZXRSb290QXR0cmlidXRlcyhyb290TmFtZSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdEYXRhKS5sZW5ndGgpIHtcbiAgICAgICAgc2V0RGF0YSgocHJldmlvdXNEYXRhKSA9PiAoeyAuLi5wcmV2aW91c0RhdGEsIC4uLm5ld0RhdGEgfSkpO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld0F0dHJpYnV0ZXMpLmxlbmd0aCkge1xuICAgICAgICBzZXRBdHRyaWJ1dGVzKChwcmV2aW91c0F0dHJpYnV0ZXMpID0+ICh7IC4uLnByZXZpb3VzQXR0cmlidXRlcywgLi4ubmV3QXR0cmlidXRlcyB9KSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0tIEBwcmVzZXJ2ZSAqL1xuICAgIGlmIChwcm9wcy5vbkNoYW5nZSkge1xuICAgICAgcHJvcHMub25DaGFuZ2UoZXZlbnQsIGVkaXRvcik7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgb25BZGRSb290ID0gdXNlUmVmU2FmZUNhbGxiYWNrKChlZGl0b3IsIF9ldnQsIHJvb3QpID0+IHtcbiAgICBjb25zdCByb290TmFtZSA9IHJvb3Qucm9vdE5hbWU7XG4gICAgaWYgKCFwcm9wcy5kaXNhYmxlVHdvV2F5RGF0YUJpbmRpbmcpIHtcbiAgICAgIHNldERhdGEoXG4gICAgICAgIChwcmV2aW91c0RhdGEpID0+ICh7IC4uLnByZXZpb3VzRGF0YSwgW3Jvb3ROYW1lXTogZWRpdG9yLmdldERhdGEoeyByb290TmFtZSB9KSB9KVxuICAgICAgKTtcbiAgICAgIHNldEF0dHJpYnV0ZXMoXG4gICAgICAgIChwcmV2aW91c0F0dHJpYnV0ZXMpID0+ICh7IC4uLnByZXZpb3VzQXR0cmlidXRlcywgW3Jvb3ROYW1lXTogZWRpdG9yLmdldFJvb3RBdHRyaWJ1dGVzKHJvb3ROYW1lKSB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgc2V0Um9vdHMoKHByZXZSb290cykgPT4gdW5pcShbLi4ucHJldlJvb3RzLCByb290LnJvb3ROYW1lXSkpO1xuICB9KTtcbiAgY29uc3Qgb25EZXRhY2hSb290ID0gdXNlUmVmU2FmZUNhbGxiYWNrKChfZWRpdG9yLCBfZXZ0LCByb290KSA9PiB7XG4gICAgY29uc3Qgcm9vdE5hbWUgPSByb290LnJvb3ROYW1lO1xuICAgIGlmICghcHJvcHMuZGlzYWJsZVR3b1dheURhdGFCaW5kaW5nKSB7XG4gICAgICBzZXREYXRhKChwcmV2aW91c0RhdGEpID0+IHtcbiAgICAgICAgY29uc3QgeyBbcm9vdE5hbWVdOiBfLCAuLi5uZXdEYXRhIH0gPSBwcmV2aW91c0RhdGE7XG4gICAgICAgIHJldHVybiB7IC4uLm5ld0RhdGEgfTtcbiAgICAgIH0pO1xuICAgICAgc2V0QXR0cmlidXRlcygocHJldmlvdXNBdHRyaWJ1dGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgW3Jvb3ROYW1lXTogXywgLi4ubmV3QXR0cmlidXRlcyB9ID0gcHJldmlvdXNBdHRyaWJ1dGVzO1xuICAgICAgICByZXR1cm4geyAuLi5uZXdBdHRyaWJ1dGVzIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2V0Um9vdHMoKHByZXZSb290cykgPT4gcHJldlJvb3RzLmZpbHRlcigocm9vdDIpID0+IHJvb3QyICE9PSByb290TmFtZSkpO1xuICB9KTtcbiAgY29uc3QgX2NyZWF0ZUVkaXRvciA9IHVzZVJlZlNhZmVDYWxsYmFjaygoaW5pdGlhbERhdGEsIGNvbmZpZykgPT4ge1xuICAgIG92ZXJ3cml0ZU9iamVjdCh7IC4uLnByb3BzLnJvb3RzQXR0cmlidXRlcyB9LCBhdHRyaWJ1dGVzKTtcbiAgICBvdmVyd3JpdGVPYmplY3QoeyAuLi5wcm9wcy5kYXRhIH0sIGRhdGEpO1xuICAgIG92ZXJ3cml0ZUFycmF5KE9iamVjdC5rZXlzKHByb3BzLmRhdGEpLCByb290cyk7XG4gICAgcmV0dXJuIHByb3BzLmVkaXRvci5jcmVhdGUoXG4gICAgICBpbml0aWFsRGF0YSxcbiAgICAgIGFwcGVuZEFsbEludGVncmF0aW9uUGx1Z2luc1RvQ29uZmlnKGNvbmZpZylcbiAgICApLnRoZW4oKGVkaXRvcikgPT4ge1xuICAgICAgY29uc3QgZWRpdG9yRGF0YSA9IGVkaXRvci5nZXRGdWxsRGF0YSgpO1xuICAgICAgb3ZlcndyaXRlT2JqZWN0KHsgLi4uZWRpdG9yRGF0YSB9LCBkYXRhKTtcbiAgICAgIG92ZXJ3cml0ZU9iamVjdCh7IC4uLmVkaXRvci5nZXRSb290c0F0dHJpYnV0ZXMoKSB9LCBhdHRyaWJ1dGVzKTtcbiAgICAgIG92ZXJ3cml0ZUFycmF5KE9iamVjdC5rZXlzKGVkaXRvckRhdGEpLCByb290cyk7XG4gICAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLS0gQHByZXNlcnZlICovXG4gICAgICAgIGVkaXRvci5lbmFibGVSZWFkT25seU1vZGUoUkVBQ1RfSU5URUdSQVRJT05fUkVBRF9PTkxZX0xPQ0tfSUQpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWxEb2N1bWVudCA9IGVkaXRvci5tb2RlbC5kb2N1bWVudDtcbiAgICAgIGNvbnN0IHZpZXdEb2N1bWVudCA9IGVkaXRvci5lZGl0aW5nLnZpZXcuZG9jdW1lbnQ7XG4gICAgICBtb2RlbERvY3VtZW50Lm9uKFwiY2hhbmdlOmRhdGFcIiwgKGV2dCkgPT4gb25DaGFuZ2VEYXRhKGVkaXRvciwgZXZ0KSk7XG4gICAgICBlZGl0b3Iub24oXCJhZGRSb290XCIsIChldnQsIHJvb3QpID0+IG9uQWRkUm9vdChlZGl0b3IsIGV2dCwgcm9vdCkpO1xuICAgICAgZWRpdG9yLm9uKFwiZGV0YWNoUm9vdFwiLCAoZXZ0LCByb290KSA9PiBvbkRldGFjaFJvb3QoZWRpdG9yLCBldnQsIHJvb3QpKTtcbiAgICAgIHZpZXdEb2N1bWVudC5vbihcImZvY3VzXCIsIChldmVudCkgPT4ge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtLSBAcHJlc2VydmUgKi9cbiAgICAgICAgaWYgKHByb3BzLm9uRm9jdXMpIHtcbiAgICAgICAgICBwcm9wcy5vbkZvY3VzKGV2ZW50LCBlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZpZXdEb2N1bWVudC5vbihcImJsdXJcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0tIEBwcmVzZXJ2ZSAqL1xuICAgICAgICBpZiAocHJvcHMub25CbHVyKSB7XG4gICAgICAgICAgcHJvcHMub25CbHVyKGV2ZW50LCBlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBfZGVzdHJveUVkaXRvciA9IChpbml0aWFsaXplUmVzdWx0KSA9PiB7XG4gICAgY29uc3QgeyB3YXRjaGRvZywgaW5zdGFuY2UgfSA9IGluaXRpYWxpemVSZXN1bHQ7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0tIEBwcmVzZXJ2ZSAqL1xuICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHdhdGNoZG9nKSB7XG4gICAgICAgICAgICBhd2FpdCB3YXRjaGRvZy5kZXN0cm95KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGF3YWl0IGluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgX2luaXRpYWxpemVFZGl0b3IgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKHByb3BzLmRpc2FibGVXYXRjaGRvZykge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBhd2FpdCBfY3JlYXRlRWRpdG9yKHByb3BzLmRhdGEsIF9nZXRDb25maWcoKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgd2F0Y2hkb2c6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHdhdGNoZG9nID0gKCgpID0+IHtcbiAgICAgIGlmIChpc0NvbnRleHRXYXRjaGRvZ1JlYWR5VG9Vc2UoY29udGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JXYXRjaGRvZ0FkYXB0ZXIoY29udGV4dC53YXRjaGRvZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IHByb3BzLmVkaXRvci5FZGl0b3JXYXRjaGRvZyhwcm9wcy5lZGl0b3IsIHByb3BzLndhdGNoZG9nQ29uZmlnKTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHRvdGFsUmVzdGFydHNSZWYgPSB7XG4gICAgICBjdXJyZW50OiAwXG4gICAgfTtcbiAgICB3YXRjaGRvZy5zZXRDcmVhdG9yKGFzeW5jIChfLCBjb25maWcpID0+IHtcbiAgICAgIGNvbnN0IHsgb25BZnRlckRlc3Ryb3kgfSA9IHByb3BzO1xuICAgICAgaWYgKHRvdGFsUmVzdGFydHNSZWYuY3VycmVudCA+IDAgJiYgb25BZnRlckRlc3Ryb3kgJiYgZWRpdG9yUmVmcy5pbnN0YW5jZS5jdXJyZW50KSB7XG4gICAgICAgIG9uQWZ0ZXJEZXN0cm95KGVkaXRvclJlZnMuaW5zdGFuY2UuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGF3YWl0IF9jcmVhdGVFZGl0b3IoZGF0YSwgY29uZmlnKTtcbiAgICAgIGlmICh0b3RhbFJlc3RhcnRzUmVmLmN1cnJlbnQgPiAwKSB7XG4gICAgICAgIHNlbWFwaG9yZS51bnNhZmVTZXRWYWx1ZSh7XG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgd2F0Y2hkb2dcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0tIEBwcmVzZXJ2ZSAqL1xuICAgICAgICAgIGlmIChwcm9wcy5vblJlYWR5KSB7XG4gICAgICAgICAgICBwcm9wcy5vblJlYWR5KHdhdGNoZG9nLmVkaXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRvdGFsUmVzdGFydHNSZWYuY3VycmVudCsrO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0pO1xuICAgIHdhdGNoZG9nLm9uKFwiZXJyb3JcIiwgKF8sIHsgZXJyb3IsIGNhdXNlc1Jlc3RhcnQgfSkgPT4ge1xuICAgICAgY29uc3Qgb25FcnJvciA9IHByb3BzLm9uRXJyb3IgfHwgY29uc29sZS5lcnJvcjtcbiAgICAgIG9uRXJyb3IoZXJyb3IsIHsgcGhhc2U6IFwicnVudGltZVwiLCB3aWxsRWRpdG9yUmVzdGFydDogY2F1c2VzUmVzdGFydCB9KTtcbiAgICB9KTtcbiAgICBhd2FpdCB3YXRjaGRvZy5jcmVhdGUoZGF0YSwgX2dldENvbmZpZygpKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIGNvbnN0IG9uRXJyb3IgPSBwcm9wcy5vbkVycm9yIHx8IGNvbnNvbGUuZXJyb3I7XG4gICAgICBvbkVycm9yKGVycm9yLCB7IHBoYXNlOiBcImluaXRpYWxpemF0aW9uXCIsIHdpbGxFZGl0b3JSZXN0YXJ0OiBmYWxzZSB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB3YXRjaGRvZyxcbiAgICAgIGluc3RhbmNlOiB3YXRjaGRvZy5lZGl0b3JcbiAgICB9O1xuICB9O1xuICBjb25zdCBfZ2V0U3RhdGVEaWZmID0gKHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlKSA9PiB7XG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZUtleXMgPSBPYmplY3Qua2V5cyhwcmV2aW91c1N0YXRlKTtcbiAgICBjb25zdCBuZXdTdGF0ZUtleXMgPSBPYmplY3Qua2V5cyhuZXdTdGF0ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZGVkS2V5czogbmV3U3RhdGVLZXlzLmZpbHRlcigoa2V5KSA9PiAhcHJldmlvdXNTdGF0ZUtleXMuaW5jbHVkZXMoa2V5KSksXG4gICAgICByZW1vdmVkS2V5czogcHJldmlvdXNTdGF0ZUtleXMuZmlsdGVyKChrZXkpID0+ICFuZXdTdGF0ZUtleXMuaW5jbHVkZXMoa2V5KSlcbiAgICB9O1xuICB9O1xuICBjb25zdCBfZXh0ZXJuYWxTZXREYXRhID0gdXNlQ2FsbGJhY2soXG4gICAgKG5ld0RhdGEpID0+IHtcbiAgICAgIHNlbWFwaG9yZS5ydW5BZnRlck1vdW50KCgpID0+IHtcbiAgICAgICAgc2hvdWxkVXBkYXRlRWRpdG9yLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBzZXREYXRhKG5ld0RhdGEpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBbc2V0RGF0YV1cbiAgKTtcbiAgY29uc3QgX2V4dGVybmFsU2V0QXR0cmlidXRlcyA9IHVzZUNhbGxiYWNrKFxuICAgIChuZXdBdHRyaWJ1dGVzKSA9PiB7XG4gICAgICBzZW1hcGhvcmUucnVuQWZ0ZXJNb3VudCgoKSA9PiB7XG4gICAgICAgIHNob3VsZFVwZGF0ZUVkaXRvci5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgc2V0QXR0cmlidXRlcyhuZXdBdHRyaWJ1dGVzKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW3NldEF0dHJpYnV0ZXNdXG4gICk7XG4gIGNvbnN0IHRvb2xiYXJFbGVtZW50ID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgRWRpdG9yVG9vbGJhcldyYXBwZXIsXG4gICAge1xuICAgICAgcmVmOiBzZW1hcGhvcmVFbGVtZW50UmVmLFxuICAgICAgZWRpdG9yOiBlZGl0b3JSZWZzLmluc3RhbmNlLmN1cnJlbnRcbiAgICB9XG4gICk7XG4gIHVzZUluc3RhbnRFZGl0b3JFZmZlY3Qoc2VtYXBob3JlLmN1cnJlbnQsICh7IGluc3RhbmNlIH0pID0+IHtcbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIGluc3RhbmNlLmVuYWJsZVJlYWRPbmx5TW9kZShSRUFDVF9JTlRFR1JBVElPTl9SRUFEX09OTFlfTE9DS19JRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLmRpc2FibGVSZWFkT25seU1vZGUoUkVBQ1RfSU5URUdSQVRJT05fUkVBRF9PTkxZX0xPQ0tfSUQpO1xuICAgIH1cbiAgfSwgW3Byb3BzLmRpc2FibGVkXSk7XG4gIHVzZUluc3RhbnRFZGl0b3JFZmZlY3Qoc2VtYXBob3JlLmN1cnJlbnQsICh7IGluc3RhbmNlIH0pID0+IHtcbiAgICBpZiAoc2hvdWxkVXBkYXRlRWRpdG9yLmN1cnJlbnQpIHtcbiAgICAgIHNob3VsZFVwZGF0ZUVkaXRvci5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBjb25zdCBkYXRhS2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgY29uc3QgYXR0cmlidXRlc0tleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTtcbiAgICAgIGlmICghZGF0YUtleXMuZXZlcnkoKGtleSkgPT4gYXR0cmlidXRlc0tleXMuaW5jbHVkZXMoa2V5KSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcImBkYXRhYCBhbmQgYGF0dHJpYnV0ZXNgIG9iamVjdHMgbXVzdCBoYXZlIHRoZSBzYW1lIGtleXMgKHJvb3RzKS5cIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBkYXRhYCBhbmQgYGF0dHJpYnV0ZXNgIG9iamVjdHMgbXVzdCBoYXZlIHRoZSBzYW1lIGtleXMgKHJvb3RzKS5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0b3JEYXRhID0gaW5zdGFuY2UuZ2V0RnVsbERhdGEoKTtcbiAgICAgIGNvbnN0IGVkaXRvckF0dHJpYnV0ZXMgPSBpbnN0YW5jZS5nZXRSb290c0F0dHJpYnV0ZXMoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWRkZWRLZXlzOiBuZXdSb290cyxcbiAgICAgICAgcmVtb3ZlZEtleXM6IHJlbW92ZWRSb290c1xuICAgICAgfSA9IF9nZXRTdGF0ZURpZmYoXG4gICAgICAgIGVkaXRvckRhdGEsXG4gICAgICAgIGRhdGEgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLS0gQHByZXNlcnZlOiBJdCBzaG91bGQgbmV2ZXIgaGFwcGVuLCBkYXRhIHNob3VsZCBiZSBhbHdheXMgZmlsbGVkLiAqL1xuICAgICAgICB7fVxuICAgICAgKTtcbiAgICAgIGNvbnN0IG1vZGlmaWVkUm9vdHMgPSBkYXRhS2V5cy5maWx0ZXIoXG4gICAgICAgIChyb290TmFtZSkgPT4gZWRpdG9yRGF0YVtyb290TmFtZV0gIT09IHZvaWQgMCAmJiBKU09OLnN0cmluZ2lmeShlZGl0b3JEYXRhW3Jvb3ROYW1lXSkgIT09IEpTT04uc3RyaW5naWZ5KGRhdGFbcm9vdE5hbWVdKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJvb3RzV2l0aENoYW5nZWRBdHRyaWJ1dGVzID0gYXR0cmlidXRlc0tleXMuZmlsdGVyKChyb290TmFtZSkgPT4gSlNPTi5zdHJpbmdpZnkoZWRpdG9yQXR0cmlidXRlc1tyb290TmFtZV0pICE9PSBKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGVzW3Jvb3ROYW1lXSkpO1xuICAgICAgY29uc3QgX2hhbmRsZU5ld1Jvb3RzID0gKHJvb3RzMikgPT4ge1xuICAgICAgICByb290czIuZm9yRWFjaCgocm9vdE5hbWUpID0+IHtcbiAgICAgICAgICBpbnN0YW5jZS5hZGRSb290KHJvb3ROYW1lLCB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhW3Jvb3ROYW1lXSB8fCBcIlwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogKGF0dHJpYnV0ZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGF0dHJpYnV0ZXNbcm9vdE5hbWVdKSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtLSBAcHJlc2VydmU6IGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGluIHN5bmMgd2l0aCByb290IGtleXMgKi9cbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgaXNVbmRvYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBfaGFuZGxlUmVtb3ZlZFJvb3RzID0gKHJvb3RzMikgPT4ge1xuICAgICAgICByb290czIuZm9yRWFjaCgocm9vdE5hbWUpID0+IHtcbiAgICAgICAgICBpbnN0YW5jZS5kZXRhY2hSb290KHJvb3ROYW1lLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgX3VwZGF0ZUVkaXRvckRhdGEgPSAocm9vdHMyKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGFUb1VwZGF0ZSA9IHJvb3RzMi5yZWR1Y2UoXG4gICAgICAgICAgKHJlc3VsdCwgcm9vdE5hbWUpID0+ICh7IC4uLnJlc3VsdCwgW3Jvb3ROYW1lXTogZGF0YVtyb290TmFtZV0gfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgKTtcbiAgICAgICAgaW5zdGFuY2UuZGF0YS5zZXQoZGF0YVRvVXBkYXRlLCB7IHN1cHByZXNzRXJyb3JJbkNvbGxhYm9yYXRpb246IHRydWUgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgX3VwZGF0ZUVkaXRvckF0dHJpYnV0ZXMgPSAod3JpdGVyLCByb290czIpID0+IHtcbiAgICAgICAgcm9vdHMyLmZvckVhY2goKHJvb3ROYW1lKSA9PiB7XG4gICAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlc1tyb290TmFtZV0pLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgICAgICAgIGluc3RhbmNlLnJlZ2lzdGVyUm9vdEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB3cml0ZXIuY2xlYXJBdHRyaWJ1dGVzKGluc3RhbmNlLm1vZGVsLmRvY3VtZW50LmdldFJvb3Qocm9vdE5hbWUpKTtcbiAgICAgICAgICB3cml0ZXIuc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzW3Jvb3ROYW1lXSwgaW5zdGFuY2UubW9kZWwuZG9jdW1lbnQuZ2V0Um9vdChyb290TmFtZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaW5zdGFuY2UubW9kZWwuY2hhbmdlKCh3cml0ZXIpID0+IHtcbiAgICAgICAgICBfaGFuZGxlTmV3Um9vdHMobmV3Um9vdHMpO1xuICAgICAgICAgIF9oYW5kbGVSZW1vdmVkUm9vdHMocmVtb3ZlZFJvb3RzKTtcbiAgICAgICAgICBpZiAobW9kaWZpZWRSb290cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIF91cGRhdGVFZGl0b3JEYXRhKG1vZGlmaWVkUm9vdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocm9vdHNXaXRoQ2hhbmdlZEF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBfdXBkYXRlRWRpdG9yQXR0cmlidXRlcyh3cml0ZXIsIHJvb3RzV2l0aENoYW5nZWRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZGF0YSwgYXR0cmlidXRlc10pO1xuICBjb25zdCBlZGl0YWJsZUVsZW1lbnRzID0gcm9vdHMubWFwKFxuICAgIChyb290TmFtZSkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBFZGl0b3JFZGl0YWJsZSxcbiAgICAgIHtcbiAgICAgICAga2V5OiByb290TmFtZSxcbiAgICAgICAgaWQ6IHJvb3ROYW1lLFxuICAgICAgICByb290TmFtZSxcbiAgICAgICAgc2VtYXBob3JlXG4gICAgICB9XG4gICAgKVxuICApO1xuICByZXR1cm4ge1xuICAgIGVkaXRvcjogZWRpdG9yUmVmcy5pbnN0YW5jZS5jdXJyZW50LFxuICAgIGVkaXRhYmxlRWxlbWVudHMsXG4gICAgdG9vbGJhckVsZW1lbnQsXG4gICAgZGF0YSxcbiAgICBzZXREYXRhOiBfZXh0ZXJuYWxTZXREYXRhLFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgc2V0QXR0cmlidXRlczogX2V4dGVybmFsU2V0QXR0cmlidXRlc1xuICB9O1xufTtcbmNvbnN0IEVkaXRvckVkaXRhYmxlID0gbWVtbyhmb3J3YXJkUmVmKCh7IGlkLCBzZW1hcGhvcmUsIHJvb3ROYW1lIH0sIHJlZikgPT4ge1xuICBjb25zdCBpbm5lclJlZiA9IHVzZVJlZihudWxsKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgZWRpdGFibGU7XG4gICAgbGV0IGVkaXRvcjtcbiAgICBzZW1hcGhvcmUucnVuQWZ0ZXJNb3VudCgoeyBpbnN0YW5jZSB9KSA9PiB7XG4gICAgICBpZiAoIWlubmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWRpdG9yID0gaW5zdGFuY2U7XG4gICAgICBjb25zdCB7IHVpLCBtb2RlbCB9ID0gZWRpdG9yO1xuICAgICAgY29uc3Qgcm9vdCA9IG1vZGVsLmRvY3VtZW50LmdldFJvb3Qocm9vdE5hbWUpO1xuICAgICAgaWYgKHJvb3QgJiYgZWRpdG9yLnVpLmdldEVkaXRhYmxlRWxlbWVudChyb290TmFtZSkpIHtcbiAgICAgICAgZWRpdG9yLmRldGFjaEVkaXRhYmxlKHJvb3QpO1xuICAgICAgfVxuICAgICAgZWRpdGFibGUgPSB1aS52aWV3LmNyZWF0ZUVkaXRhYmxlKHJvb3ROYW1lLCBpbm5lclJlZi5jdXJyZW50KTtcbiAgICAgIHVpLmFkZEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICAgIGluc3RhbmNlLmVkaXRpbmcudmlldy5mb3JjZVJlbmRlcigpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtLSBAcHJlc2VydmU6IEl0IGRlcGVuZHMgb24gdGhlIHZlcnNpb24gb2YgdGhlIFJlYWN0IGFuZCBtYXkgbm90IGhhcHBlbiBhbGwgb2YgdGhlIHRpbWVzLiAqL1xuICAgICAgaWYgKGVkaXRvciAmJiBlZGl0b3Iuc3RhdGUgIT09IFwiZGVzdHJveWVkXCIgJiYgaW5uZXJSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCByb290ID0gZWRpdG9yLm1vZGVsLmRvY3VtZW50LmdldFJvb3Qocm9vdE5hbWUpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtLSBAcHJlc2VydmUgKi9cbiAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICBlZGl0b3IuZGV0YWNoRWRpdGFibGUocm9vdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbc2VtYXBob3JlLnJldmlzaW9uXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGtleTogc2VtYXBob3JlLnJldmlzaW9uLFxuICAgICAgaWQsXG4gICAgICByZWY6IG1lcmdlUmVmcyhyZWYsIGlubmVyUmVmKVxuICAgIH1cbiAgKTtcbn0pKTtcbkVkaXRvckVkaXRhYmxlLmRpc3BsYXlOYW1lID0gXCJFZGl0b3JFZGl0YWJsZVwiO1xuY29uc3QgRWRpdG9yVG9vbGJhcldyYXBwZXIgPSBmb3J3YXJkUmVmKCh7IGVkaXRvciB9LCByZWYpID0+IHtcbiAgY29uc3QgdG9vbGJhclJlZiA9IHVzZVJlZihudWxsKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB0b29sYmFyQ29udGFpbmVyID0gdG9vbGJhclJlZi5jdXJyZW50O1xuICAgIGlmICghZWRpdG9yIHx8ICF0b29sYmFyQ29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50ID0gZWRpdG9yLnVpLnZpZXcudG9vbGJhci5lbGVtZW50O1xuICAgIHRvb2xiYXJDb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh0b29sYmFyQ29udGFpbmVyLmNvbnRhaW5zKGVsZW1lbnQpKSB7XG4gICAgICAgIHRvb2xiYXJDb250YWluZXIucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VkaXRvciAmJiBlZGl0b3IuaWRdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBtZXJnZVJlZnModG9vbGJhclJlZiwgcmVmKSB9KTtcbn0pO1xuRWRpdG9yVG9vbGJhcldyYXBwZXIuZGlzcGxheU5hbWUgPSBcIkVkaXRvclRvb2xiYXJXcmFwcGVyXCI7XG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmNvbnN0IHVzZUlzVW5tb3VudGVkUmVmID0gKCkgPT4ge1xuICBjb25zdCBtb3VudGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBtb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBtb3VudGVkUmVmO1xufTtcbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuY29uc3QgdXNlQXN5bmNDYWxsYmFjayA9IChjYWxsYmFjaykgPT4ge1xuICBjb25zdCBbYXN5bmNTdGF0ZSwgc2V0QXN5bmNTdGF0ZV0gPSB1c2VTdGF0ZSh7XG4gICAgc3RhdHVzOiBcImlkbGVcIlxuICB9KTtcbiAgY29uc3QgdW5tb3VudGVkUmVmID0gdXNlSXNVbm1vdW50ZWRSZWYoKTtcbiAgY29uc3QgcHJldkV4ZWN1dGlvblVJRFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgYXN5bmNFeGVjdXRvciA9IHVzZVJlZlNhZmVDYWxsYmFjayhhc3luYyAoLi4uYXJncykgPT4ge1xuICAgIGlmICh1bm1vdW50ZWRSZWYuY3VycmVudCB8fCBpc1NTUigpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEV4ZWN1dGlvblVVSUQgPSB1aWQoKTtcbiAgICBwcmV2RXhlY3V0aW9uVUlEUmVmLmN1cnJlbnQgPSBjdXJyZW50RXhlY3V0aW9uVVVJRDtcbiAgICB0cnkge1xuICAgICAgaWYgKGFzeW5jU3RhdGUuc3RhdHVzICE9PSBcImxvYWRpbmdcIikge1xuICAgICAgICBzZXRBc3luY1N0YXRlKHtcbiAgICAgICAgICBzdGF0dXM6IFwibG9hZGluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsbGJhY2soLi4uYXJncyk7XG4gICAgICBpZiAoIXVubW91bnRlZFJlZi5jdXJyZW50ICYmIHByZXZFeGVjdXRpb25VSURSZWYuY3VycmVudCA9PT0gY3VycmVudEV4ZWN1dGlvblVVSUQpIHtcbiAgICAgICAgc2V0QXN5bmNTdGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICBkYXRhOiByZXN1bHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIGlmICghdW5tb3VudGVkUmVmLmN1cnJlbnQgJiYgcHJldkV4ZWN1dGlvblVJRFJlZi5jdXJyZW50ID09PSBjdXJyZW50RXhlY3V0aW9uVVVJRCkge1xuICAgICAgICBzZXRBc3luY1N0YXRlKHtcbiAgICAgICAgICBzdGF0dXM6IFwiZXJyb3JcIixcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pO1xuICByZXR1cm4gW2FzeW5jRXhlY3V0b3IsIGFzeW5jU3RhdGVdO1xufTtcbi8qKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDAzLTIwMjUsIENLU291cmNlIEhvbGRpbmcgc3AuIHogby5vLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cHM6Ly9ja2VkaXRvci5jb20vbGVnYWwvY2tlZGl0b3ItbGljZW5zaW5nLW9wdGlvbnNcbiAqL1xuY29uc3QgdXNlQXN5bmNWYWx1ZSA9IChjYWxsYmFjaywgZGVwcykgPT4ge1xuICBjb25zdCBbYXN5bmNDYWxsYmFjaywgYXN5bmNTdGF0ZV0gPSB1c2VBc3luY0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgdXNlSW5zdGFudEVmZmVjdChhc3luY0NhbGxiYWNrLCBkZXBzKTtcbiAgaWYgKGFzeW5jU3RhdGUuc3RhdHVzID09PSBcImlkbGVcIikge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IFwibG9hZGluZ1wiXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYXN5bmNTdGF0ZTtcbn07XG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZUNLRWRpdG9yQ2xvdWQoY29uZmlnKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWRDb25maWdLZXkgPSBKU09OLnN0cmluZ2lmeShjb25maWcpO1xuICBjb25zdCByZXN1bHQgPSB1c2VBc3luY1ZhbHVlKFxuICAgIGFzeW5jICgpID0+IGxvYWRDS0VkaXRvckNsb3VkKGNvbmZpZyksXG4gICAgW3NlcmlhbGl6ZWRDb25maWdLZXldXG4gICk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSBcInN1Y2Nlc3NcIikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXN1bHQuZGF0YSxcbiAgICAgIHN0YXR1czogXCJzdWNjZXNzXCJcbiAgICB9O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDI1LCBDS1NvdXJjZSBIb2xkaW5nIHNwLiB6IG8uby4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEZvciBsaWNlbnNpbmcsIHNlZSBMSUNFTlNFLm1kIG9yIGh0dHBzOi8vY2tlZGl0b3IuY29tL2xlZ2FsL2NrZWRpdG9yLWxpY2Vuc2luZy1vcHRpb25zXG4gKi9cbmNvbnN0IHdpdGhDS0VkaXRvckNsb3VkID0gKGNvbmZpZykgPT4gKFdyYXBwZWRDb21wb25lbnQpID0+IHtcbiAgY29uc3QgQ29tcG9uZW50V2l0aENLRWRpdG9yQ2xvdWQgPSAocHJvcHMpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGNrZWRpdG9yQ2xvdWRSZXN1bHQgPSB1c2VDS0VkaXRvckNsb3VkKGNvbmZpZy5jbG91ZCk7XG4gICAgc3dpdGNoIChja2VkaXRvckNsb3VkUmVzdWx0LnN0YXR1cykge1xuICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgIGlmICghY29uZmlnLnJlbmRlckVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIFwiVW5hYmxlIHRvIGxvYWQgQ0tFZGl0b3IgQ2xvdWQgZGF0YSFcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnLnJlbmRlckVycm9yKGNrZWRpdG9yQ2xvdWRSZXN1bHQuZXJyb3IpO1xuICAgICAgY2FzZSBcInN1Y2Nlc3NcIjpcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFdyYXBwZWRDb21wb25lbnQsIHsgLi4ucHJvcHMsIGNsb3VkOiBja2VkaXRvckNsb3VkUmVzdWx0IH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGNvbmZpZy5yZW5kZXJMb2FkZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGNvbmZpZykpICE9IG51bGwgPyBfYiA6IG51bGw7XG4gICAgfVxuICB9O1xuICBDb21wb25lbnRXaXRoQ0tFZGl0b3JDbG91ZC5kaXNwbGF5TmFtZSA9IFwiQ29tcG9uZW50V2l0aENLRWRpdG9yQ2xvdWRcIjtcbiAgcmV0dXJuIENvbXBvbmVudFdpdGhDS0VkaXRvckNsb3VkO1xufTtcbmV4cG9ydCB7XG4gIENLRWRpdG9yLFxuICBDS0VkaXRvckNvbnRleHQsXG4gIGxvYWRDS0VkaXRvckNsb3VkMiBhcyBsb2FkQ0tFZGl0b3JDbG91ZCxcbiAgdXNlQ0tFZGl0b3JDbG91ZCxcbiAgdXNlTXVsdGlSb290RWRpdG9yLFxuICB3aXRoQ0tFZGl0b3JDbG91ZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@ckeditor/ckeditor5-react/dist/index.js\n"));

/***/ })

}]);